{
  "articles": [
    {
      "path": "2015.html",
      "title": "Solutions for AOC 2015",
      "description": "The Advent that started it all!\n",
      "author": [],
      "contents": "\r\n\r\nDay 1\r\nhttps://adventofcode.com/2015/day/1\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(1,2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2015/day-01-input.txt\"))\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nx <- strsplit(input,\"\") |> unlist()\r\nsum(x == \"(\") - sum(x == \")\")\r\n\r\n\r\n[1] 232\r\n\r\n— Part 2 —\r\n\r\n\r\ny <- case_when(x == \"(\" ~ 1, x == \")\" ~ -1, TRUE ~ 0)\r\nwhich(cumsum(y)==-1)[1]\r\n\r\n\r\n[1] 1783\r\n\r\n\r\nDay 2\r\nhttps://adventofcode.com/2015/day/2\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 2, year = 2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2015/day-02-input.txt\"))\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\ntibble(x = input) |> \r\n  separate(x, into = c(\"l\",\"w\",\"h\"), sep = \"x\",convert = TRUE) |> \r\n  mutate(lw = l * w,\r\n         wh = w * h,\r\n         lh = l * h,\r\n         sf = 2*lw + 2*wh + 2*lh + pmap_dbl(list(lw,wh,lh), ~min(c(...)))\r\n  ) |> \r\n  pull(sf) |> \r\n  sum()\r\n\r\n\r\n[1] 1586300\r\n\r\n— Part 2 —\r\n\r\n\r\ntibble(x = input) |> \r\n  separate(x, into = c(\"l\",\"w\",\"h\"), sep = \"x\",convert = TRUE) |> \r\n  mutate(lw = l + w,\r\n         wh = w + h,\r\n         lh = l + h,\r\n         r = pmap_dbl(list(lw,wh,lh), ~ 2*min(c(...))) + l * w * h\r\n  ) |> \r\n  pull(r) |> \r\n  sum()\r\n\r\n\r\n[1] 3737498\r\n\r\n\r\nDay 3\r\nhttps://adventofcode.com/2015/day/3\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 3, year = 2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2015/day-03-input.txt\")) |>\r\n  strsplit(\"\") |>\r\n  unlist()\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nvisit <- function(position,move){\r\n  switch(move,\r\n         \">\" = position[1] <- position[1] + 1,\r\n         \"<\" = position[1] <- position[1] - 1,\r\n         \"^\" = position[2] <- position[2] + 1,\r\n         \"v\" = position[2] <- position[2] - 1,\r\n  )\r\n  return(position)\r\n}\r\n\r\npurrr::accumulate(input,visit, .init = c(0,0)) |> unique() |> length()\r\n\r\n\r\n[1] 2565\r\n\r\n— Part 2 —\r\ndivvy up half to santa and half to robosanta\r\n\r\n\r\nsanta <- input[rep_len(c(TRUE,FALSE),length(input))]\r\nrobosanta <- input[rep_len(c(FALSE,TRUE),length(input))]\r\n\r\nc(purrr::accumulate(santa,visit, .init = c(0,0)),\r\n  purrr::accumulate(robosanta,visit, .init = c(0,0))) |> \r\n  unique() |> \r\n  length()\r\n\r\n\r\n[1] 2639\r\n\r\n\r\nDay 4\r\nhttps://adventofcode.com/2015/day/4\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 4, year = 2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2015/day-04-input.txt\"))\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nlibrary(digest)\r\n\r\ni <- 1\r\n\r\nrepeat{\r\n  if(i %% 100000 == 0) cat(i,\"\\n\")\r\n  key <- digest::digest(paste0(input,i),algo = \"md5\", serialize = FALSE)\r\n  if(str_starts(key,\"00000\")) break\r\n  i <- i+1\r\n}\r\n\r\n\r\n100000 \r\n\r\n— Part 2 —\r\nHmm. Slow. Switching to vector version, which seems to be supplied as a function factory?\r\n\r\n\r\nlibrary(digest)\r\n\r\nhash <- digest::getVDigest(algo = \"md5\",errormode = \"silent\")\r\nv <- hash(paste0(input,1:4000000),serialize = FALSE)\r\nmin(which(str_starts(v,\"000000\")))\r\n\r\n\r\n[1] 3938038\r\n\r\n\r\nDay 5\r\nhttps://adventofcode.com/2015/day/5\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 5, year = 2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2015/day-05-input.txt\"))\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nx <- input[!stringr::str_detect(input,\"ab|cd|pq|xy\")]\r\n\r\ny <- x[strsplit(x,\"\") |> map_dbl(~sum(.x %in% c(\"a\",\"e\",\"i\",\"o\",\"u\"))) >= 3]\r\n\r\nz <- y[map_lgl(strsplit(y,\"\"),~any(rle(.x)$lengths>=2))]\r\n\r\nlength(z)\r\n\r\n\r\n[1] 258\r\n\r\n— Part 2 —\r\n\r\n\r\na <- input[strsplit(input,\"\") |> map_lgl(~any(lead(.x,n = 2,default = \"\")==.x))]\r\n\r\npairchecker <- function(s){\r\n  ss <- strsplit(s,\"\") |> unlist()\r\n  ss <- paste0(ss,lead(ss, default = \"1\"))\r\n  \r\n  any(map_lgl(ss, \r\n              ~str_replace(string = s,pattern = .x,replacement = \"2\") |>\r\n                str_detect(pattern = .x)))\r\n}\r\n\r\nb <- a[map_lgl(a,pairchecker)]\r\n\r\nlength(b)\r\n\r\n\r\n[1] 53\r\n\r\n\r\nDay 6\r\nhttps://adventofcode.com/2015/day/6\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 6, year = 2015)\r\n\r\n\r\n\r\n\r\n\r\ninput <- tibble(x = readLines(here::here(\"2015/day-06-input.txt\"))) |> \r\n  extract(x, into = c(\"action\",\"x1\",\"y1\",\"x2\",\"y2\"),\r\n          regex = \"([a-z, ]+) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)\",\r\n          convert = TRUE) |> \r\n  mutate(\r\n    id = row_number(),\r\n    .before = 1\r\n  )\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nlights <- matrix(-1,nrow = 1000, ncol = 1000)\r\n\r\ninstructions <- input |> \r\n  mutate(\r\n    references = pmap(list(x1,y1,x2,y2),\r\n                      ~crossing(y = ..2:..4,\r\n                                x = ..1:..3) |> \r\n                        as.matrix())\r\n  )\r\n\r\nfor(i in instructions$id){\r\n  switch(instructions$action[i],\r\n         \"turn on\" = lights[instructions$references[[i]]] <- 1,\r\n         \"turn off\" = lights[instructions$references[[i]]] <- -1,\r\n         \"toggle\" = lights[instructions$references[[i]]] <- lights[instructions$references[[i]]] * -1\r\n         )\r\n}\r\n\r\nsum(lights == 1)\r\n\r\n\r\n[1] 377891\r\n\r\n— Part 2 —\r\n\r\n\r\nlights <- matrix(0,nrow = 1000, ncol = 1000)\r\n\r\ninstructions <- input |> \r\n  mutate(\r\n    references = pmap(list(x1,y1,x2,y2),\r\n                      ~crossing(y = ..2:..4,\r\n                                x = ..1:..3) |> \r\n                        as.matrix())\r\n  )\r\n\r\nfor(i in instructions$id){\r\n  switch(instructions$action[i],\r\n         \"turn on\" = lights[instructions$references[[i]]] <- lights[instructions$references[[i]]] + 1,\r\n         \"turn off\" = lights[instructions$references[[i]]] <- lights[instructions$references[[i]]] -1,\r\n         \"toggle\" = lights[instructions$references[[i]]] <- lights[instructions$references[[i]]] + 2\r\n         )\r\n  \r\n  lights[lights < 0] <- 0\r\n}\r\n\r\nsum(lights)\r\n\r\n\r\n[1] 14110788\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:04:54-05:00"
    },
    {
      "path": "2016.html",
      "title": "Solutions for AOC 2016",
      "description": "Advent of Code, the sequel!",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:04:56-05:00"
    },
    {
      "path": "2017.html",
      "title": "Solutions for AOC 2017",
      "description": "Advent of Code, episode three!",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:04:56-05:00"
    },
    {
      "path": "2018.html",
      "title": "Solutions for AOC 2018",
      "description": "Advent of Code, a new hope!",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:04:57-05:00"
    },
    {
      "path": "2019.html",
      "title": "Solutions for AOC 2019",
      "description": "Advent of Code, episode five!",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:04:58-05:00"
    },
    {
      "path": "2020.html",
      "title": "Solutions for AOC 2020",
      "description": "My first Advent of Code!",
      "author": [],
      "contents": "\r\n\r\nDay 1\r\nhttps://adventofcode.com/2020/day/1\r\n\r\n\r\n\r\n— Day 1: Report Repair —\r\nhttps://adventofcode.com/2020/day/1\r\n\r\nSpecifically, they need you to find the two entries that sum to 2020 and then multiply those two numbers together.\r\n\r\nData\r\nCopy-paste + datapasta’s Fiddle Selection. (Thank you, Miles!)\r\n\r\n\r\ninput_data <- c(\r\n  1630, 1801, 1917, 1958, 1953, 1521, 1990, 1959, 1543, 1798, \r\n  638, 1499, 1977, 1433, 1532, 1780, 1559, 1866, 1962, 1999, \r\n  1623, 1772, 1730, 1670, 1791, 1947, 1961, 1523, 959, 1998, \r\n  1693, 1490, 1712, 910, 1635, 1837, 586, 1590, 1741, 1739, \r\n  1660, 1883, 1777, 1734, 1413, 1456, 1511, 1957, 1738, 1685, \r\n  1677, 1419, 1566, 1639, 1578, 1922, 1856, 1946, 1965, 1649, \r\n  1854, 1610, 1806, 1424, 1616, 218, 1678, 1992, 1985, 903, \r\n  1626, 1412, 1964, 671, 1692, 1571, 1690, 1587, 1933, 1367, \r\n  1585, 1575, 498, 1601, 2005, 1711, 1948, 1991, 1580, 1704, \r\n  207, 1560, 1867, 1600, 1594, 1930, 1541, 1832, 1613, 1599, \r\n  1757, 71, 1534, 1940, 1982, 1960, 1530, 1908, 1857, 1410, \r\n  1987, 1526, 1546, 2002, 1923, 1972, 1752, 1984, 1754, 1916, \r\n  1942, 1980, 1608, 1398, 1438, 1955, 1968, 1799, 1976, 1847, \r\n  1775, 1904, 1983, 1945, 1554, 1486, 1527, 1884, 1553, 1736, \r\n  1561, 1513, 1695, 1431, 1997, 1405, 1872, 1434, 1679, 1609, \r\n  105, 1582, 1795, 1826, 1886, 1472, 2007, 1617, 1978, 1669, \r\n  1764, 1865, 1773, 1993, 1666, 1583, 2009, 1969, 2001, 1659, \r\n  1833, 1713, 1893, 2000, 1520, 1652, 1437, 1556, 1633, 1386, \r\n  1819, 1973, 1426, 1975, 2010, 1863, 1593, 1996, 1796, 1986, \r\n  1995, 657, 1784, 1644, 1941, 1596, 1849, 1065, 1927, 1525)\r\n\r\n\r\n\r\nPart One: Find a solution where the sum of two entries equals 2020.\r\nThe first solution that comes to mind is finding the difference each entry and 2020, and then left-joining the entries onto this difference.\r\n\r\n\r\npair_2020 <- tibble(expense = input_data) %>% \r\n  mutate(difference = 2020 - expense) %>% \r\n  left_join(\r\n    x = .,\r\n    y = .,\r\n    by = c(\"expense\"=\"difference\")\r\n  ) %>% \r\n  filter(!is.na(expense.y))\r\n\r\npair_2020\r\n\r\n\r\n# A tibble: 2 x 3\r\n  expense difference expense.y\r\n    <dbl>      <dbl>     <dbl>\r\n1     586       1434      1434\r\n2    1434        586       586\r\n\r\npair_2020 %>% \r\n  mutate(multiply = expense * expense.y) %>% \r\n  distinct(multiply) %>% \r\n  pull()\r\n\r\n\r\n[1] 840324\r\n\r\nPart Two: Find a solution where the sum of three entries equals 2020\r\nOkay, I can’t use the first solution here, so now I’ll hit crossing to make a big dataframe, then sum it all afterwards and filter to where sum == 2020.\r\n\r\n\r\ntriple_2020 <- crossing(first = input_data, \r\n                        second = input_data, \r\n                        third = input_data) %>% \r\n  mutate(total = first + second + third,\r\n         product = first * second * third) %>% \r\n  filter(total == 2020)\r\n\r\ntriple_2020\r\n\r\n\r\n# A tibble: 6 x 5\r\n  first second third total   product\r\n  <dbl>  <dbl> <dbl> <dbl>     <dbl>\r\n1   207    903   910  2020 170098110\r\n2   207    910   903  2020 170098110\r\n3   903    207   910  2020 170098110\r\n4   903    910   207  2020 170098110\r\n5   910    207   903  2020 170098110\r\n6   910    903   207  2020 170098110\r\n\r\ntriple_2020 %>% \r\n  distinct(product) %>% \r\n  pull()\r\n\r\n\r\n[1] 170098110\r\n\r\n\r\nDay 2\r\nhttps://adventofcode.com/2020/day/2\r\nDay two!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(janitor)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\nProblem\r\n\r\nTo try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.\r\nFor example, suppose you have the following list:\r\n1-3 a: abcde\r\n1-3 b: cdefg\r\n2-9 c: ccccccccc\r\nEach line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.\r\nIn the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.\r\n\r\nInput Data\r\n\r\n\r\ninput_data <- read.delim(\"day-02.txt\",header = FALSE)\r\n\r\n\r\n\r\nHow many passwords are valid?\r\n\r\n\r\npassword_table_one <- input_data %>% \r\n  separate(1,into = c(\"qty\",\"character\",\"password\"),sep = \" \") %>% \r\n  separate(qty, into = c(\"min\",\"max\"), sep = \"-\",convert = TRUE) %>% \r\n  mutate(character = str_remove(character,\":\"),\r\n         password = str_split(password,\"\"),\r\n         count = map2_dbl(password,character,~sum(.x %in% .y)),\r\n         valid = count <= max & count >=min)\r\n\r\nhead(password_table_one)\r\n\r\n\r\n  min max character\r\n1   1   4         j\r\n2   2   4         w\r\n3   1  13         b\r\n4  10  11         x\r\n5  13  14         d\r\n6  16  18         s\r\n                                              password count valid\r\n1                   j, j, j, q, z, m, g, b, j, w, p, j     5 FALSE\r\n2                                     s, c, k, w, w, f     2  TRUE\r\n3          b, c, b, b, b, b, b, b, b, b, b, b, h, b, b    13  TRUE\r\n4             x, j, x, x, x, x, x, x, x, x, z, x, x, x    12 FALSE\r\n5             d, d, d, d, d, d, d, d, d, d, d, d, d, d    14  TRUE\r\n6 k, s, t, t, b, j, s, s, t, p, n, s, v, t, c, j, n, x     4 FALSE\r\n\r\nsum(password_table_one$valid)\r\n\r\n\r\n[1] 418\r\n\r\nPart Two: how many passwords are valid under the second policy?\r\n\r\nWhile it appears you validated the passwords correctly, they don’t seem to be what the Official Toboggan Corporate Authentication System is expecting.\r\nThe shopkeeper suddenly realizes that he just accidentally explained the password policy rules from his old job at the sled rental place down the street! The Official Toboggan Corporate Policy actually works a little differently.\r\nEach policy actually describes two positions in the password, where 1 means the first character, 2 means the second character, and so on. (Be careful; Toboggan Corporate Policies have no concept of “index zero”!) Exactly one of these positions must contain the given letter. Other occurrences of the letter are irrelevant for the purposes of policy enforcement.\r\n\r\n\r\nGiven the same example list from above:\r\n\r\n\r\n1-3 a: abcde is valid: position 1 contains a and position 3 does not.\r\n1-3 b: cdefg is invalid: neither position 1 nor position 3 contains b.\r\n2-9 c: ccccccccc is invalid: both position 2 and position 9 contain c.\r\n\r\n\r\nHow many passwords are valid according to the new interpretation of the policies?\r\n\r\n\r\n\r\npassword_table_two <- input_data %>% \r\n  separate(1,into = c(\"qty\",\"character\",\"password\"),sep = \" \") %>% \r\n  separate(qty, into = c(\"pos1\",\"pos2\"), sep = \"-\",convert = TRUE) %>% \r\n  mutate(character = str_remove(character,\":\"),\r\n         password = str_split(password,\"\"),\r\n         password = pmap(list(password,pos1,pos2),~magrittr::extract(..1,c(..2,..3))),\r\n         count = map2_dbl(password,character, ~sum(.x %in% .y)),\r\n         valid = count == 1)\r\n\r\nhead(password_table_two)\r\n\r\n\r\n  pos1 pos2 character password count valid\r\n1    1    4         j     j, q     1  TRUE\r\n2    2    4         w     c, w     1  TRUE\r\n3    1   13         b     b, h     1  TRUE\r\n4   10   11         x     x, z     1  TRUE\r\n5   13   14         d     d, d     2 FALSE\r\n6   16   18         s     j, x     0 FALSE\r\n\r\nsum(password_table_two$valid)\r\n\r\n\r\n[1] 616\r\n\r\n\r\nDay 3\r\nhttps://adventofcode.com/2020/day/3\r\nDay three!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\nProblem\r\n\r\nYou start on the open square (.) in the top-left corner and need to reach the bottom (below the bottom-most row on your map).\r\nThe toboggan can only follow a few specific slopes (you opted for a cheaper model that prefers rational numbers); start by counting all the trees you would encounter for the slope right 3, down 1:\r\nFrom your starting position at the top-left, check the position that is right 3 and down 1. Then, check the position that is right 3 and down 1 from there, and so on until you go past the bottom of the map.\r\nStarting at the top-left corner of your map and following a slope of right 3 and down 1, how many trees would you encounter?\r\n\r\nInput Data\r\nConverting to a matrix of 1s and 0s, where “#” is 1 and “.” is 0\r\n\r\n\r\ninput_matrix <- read_table(\"day-03.txt\",col_names = \"x\") %>% \r\n  mutate(x = str_split(x,\"\")) %>% \r\n  unnest_wider(x,names_sep = \"_\") %>% \r\n  mutate_all(~case_when(.x == \"#\" ~ 1, .x == \".\" ~ 0)) %>% \r\n  as.matrix()\r\n\r\n\r\n\r\nProblem 1\r\n\r\nStarting at the top-left corner of your map and following a slope of right 3 and down 1, how many trees would you encounter?\r\n\r\nKey here is that the pattern repeats to the right until you get down to the bottom, i.e. until you access row 323 in this case.\r\n\r\n\r\ninput_rows <- nrow(input_matrix)\r\n\r\ninput_rows\r\n\r\n\r\n[1] 323\r\n\r\nSo 323 is the goal rows, and that means we’ll need ~ 969 columns. We can tackle this cbind with a while loop.\r\n\r\n\r\ninput_columns <- input_rows * 3\r\n\r\nwide_matrix <- input_matrix\r\n\r\nwhile(ncol(wide_matrix) < input_columns) wide_matrix <- cbind(wide_matrix,input_matrix)\r\n\r\n\r\n\r\nNow building an accessor tibble with row numbers and column numbers\r\n\r\n\r\nrow_accessor <- 2:input_rows # start at 1,1 so the next row is 2\r\n\r\ncolumn_accessor <- 1:input_rows * 3 + 1 # start at 1,1 and move right three, so next column is 4\r\n\r\ncolumn_accessor <- column_accessor[-323] # need the accessors to be same length\r\n\r\nindices <- tibble(\r\n  row = row_accessor,\r\n  column = column_accessor) %>%\r\n  mutate(path = map2_dbl(row,column,~wide_matrix[.x,.y]))\r\n  \r\nhead(indices)\r\n\r\n\r\n# A tibble: 6 x 3\r\n    row column  path\r\n  <int>  <dbl> <dbl>\r\n1     2      4     1\r\n2     3      7     1\r\n3     4     10     1\r\n4     5     13     1\r\n5     6     16     1\r\n6     7     19     1\r\n\r\nsum(indices$path)\r\n\r\n\r\n[1] 280\r\n\r\nProblem 2: Find this path for multiple slopes\r\nFind the path for\r\n1,1\r\n3,1\r\n5,1\r\n7,1\r\n1,2\r\nA good time to generalise the previous steps!\r\n\r\n\r\nfn_slope <- function(right,down,matrix){\r\n  \r\n  # Calculate number of columns\r\n  column_count <- (nrow(matrix) * right)\r\n  \r\n  # Create matrix\r\n  wide_matrix <- matrix\r\n  while(ncol(wide_matrix) < column_count) wide_matrix <- cbind(wide_matrix,matrix)\r\n  \r\n  # Create accessors\r\n  row_accessor <- (1:nrow(matrix) * down) + 1\r\n  row_accessor <- row_accessor[row_accessor <=nrow(matrix)]\r\n  \r\n  column_accessor <- (1:nrow(matrix) * right) + 1\r\n  column_accessor <- column_accessor[1:length(row_accessor)]\r\n  \r\n  x <- tibble(row = row_accessor,\r\n              column = column_accessor) %>% \r\n    mutate(path = map2_dbl(row,column,~wide_matrix[.x,.y]))\r\n  \r\n  sum(x$path)\r\n}\r\n\r\ntoboggan_paths <- tibble(right = c(1,3,5,7,1),\r\n                         down = c(1,1,1,1,2)) %>% \r\n  mutate(paths = map2_dbl(right,down,fn_slope,input_matrix))\r\n\r\ntoboggan_paths\r\n\r\n\r\n# A tibble: 5 x 3\r\n  right  down paths\r\n  <dbl> <dbl> <dbl>\r\n1     1     1    77\r\n2     3     1   280\r\n3     5     1    74\r\n4     7     1    78\r\n5     1     2    35\r\n\r\nreduce(toboggan_paths$paths,`*`)\r\n\r\n\r\n[1] 4355551200\r\n\r\n\r\nDay 4\r\nhttps://adventofcode.com/2020/day/4\r\nDay three!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\nProblem Description\r\n\r\nThe automatic passport scanners are slow because they’re having trouble detecting which passports have all required fields. The expected fields are as follows:\r\n- byr (Birth Year)\r\n- iyr (Issue Year)\r\n- eyr (Expiration Year)\r\n- hgt (Height)\r\n- hcl (Hair Color)\r\n- ecl (Eye Color)\r\n- pid (Passport ID)\r\n- cid (Country ID)\r\nPassport data is validated in batch files (your puzzle input). Each passport is represented as a sequence of key:value pairs separated by spaces or newlines. Passports are separated by blank lines.\r\n\r\nCount the number of valid passports - those that have all required fields. Treat cid as optional. In your batch file, how many passports are valid?\r\nInput Data\r\n\r\n\r\ninput_data <- read_lines(here(\"2020/day-04.txt\"))\r\n\r\nhead(input_data)\r\n\r\n\r\n[1] \"iyr:2015 cid:189 ecl:oth byr:1947 hcl:#6c4ab1 eyr:2026\"                        \r\n[2] \"hgt:174cm\"                                                                     \r\n[3] \"pid:526744288\"                                                                 \r\n[4] \"\"                                                                              \r\n[5] \"pid:688706448 iyr:2017 hgt:162cm cid:174 ecl:grn byr:1943 hcl:#808e9e eyr:2025\"\r\n[6] \"\"                                                                              \r\n\r\nCleaning data into a tibble.\r\n\r\n\r\ndf_passports <- tibble(data = input_data) %>%\r\n  mutate(blank = ifelse(data == \"\",1,0),\r\n         passport_id = cumsum(blank)+1) %>% \r\n  filter(!blank) %>% \r\n  select(-blank) %>% \r\n  separate_rows(data, sep = \" \") %>% \r\n  separate(data, sep = \":\", into = c(\"key\",\"value\")) %>% \r\n  pivot_wider(names_from = key, values_from = value)\r\n\r\nhead(df_passports)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  passport_id iyr   cid   ecl   byr   hcl     eyr   hgt   pid      \r\n        <dbl> <chr> <chr> <chr> <chr> <chr>   <chr> <chr> <chr>    \r\n1           1 2015  189   oth   1947  #6c4ab1 2026  174cm 526744288\r\n2           2 2017  174   grn   1943  #808e9e 2025  162cm 688706448\r\n3           3 2019  124   oth   1933  #733820 2001  159in 111220591\r\n4           4 2026  291   oth   1942  #fffffd 2024  159cm 812929897\r\n5           5 2013  83    amb   1974  #ceb3a1 2028  191cm 524032739\r\n6           6 <NA>  221   gry   1963  eefed5  2029  183cm 88405792 \r\n\r\nProblem 1: How many complete/non-missing passports?\r\n\r\n\r\nvalid_p1 <- df_passports %>% \r\n  select(-cid) %>% \r\n  filter_all(~!is.na(.x))\r\n\r\nhead(valid_p1)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  passport_id iyr   ecl   byr   hcl     eyr   hgt   pid      \r\n        <dbl> <chr> <chr> <chr> <chr>   <chr> <chr> <chr>    \r\n1           1 2015  oth   1947  #6c4ab1 2026  174cm 526744288\r\n2           2 2017  grn   1943  #808e9e 2025  162cm 688706448\r\n3           3 2019  oth   1933  #733820 2001  159in 111220591\r\n4           4 2026  oth   1942  #fffffd 2024  159cm 812929897\r\n5           5 2013  amb   1974  #ceb3a1 2028  191cm 524032739\r\n6           7 2018  grn   1923  #18171d 2021  181cm 777881168\r\n\r\nnrow(valid_p1)\r\n\r\n\r\n[1] 264\r\n\r\nProblem 2: Validate columns\r\n\r\n\r\nvalid_p2 <- valid_p1 %>% \r\n  mutate_at(c(\"byr\",\"iyr\",\"eyr\"),as.numeric) %>% \r\n  filter(\r\n    between(byr,1920,2002),\r\n    between(iyr,2010,2020),\r\n    between(eyr,2020,2030),\r\n    case_when(\r\n      str_ends(hgt,\"cm\") & between(parse_number(hgt),150,193) ~ TRUE,\r\n      str_ends(hgt,\"in\") & between(parse_number(hgt),59,76) ~ TRUE,\r\n      TRUE ~ FALSE\r\n      ),\r\n    str_detect(hcl,\"^#[A-z,0-9]{6}$\"),\r\n    ecl %in% c(\"amb\",\"blu\",\"brn\",\"gry\",\"grn\",\"hzl\",\"oth\"),\r\n    str_detect(pid,\"^[0-9]{9}$\"),\r\n  )\r\n\r\nhead(valid_p2)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  passport_id   iyr ecl     byr hcl       eyr hgt   pid      \r\n        <dbl> <dbl> <chr> <dbl> <chr>   <dbl> <chr> <chr>    \r\n1           1  2015 oth    1947 #6c4ab1  2026 174cm 526744288\r\n2           2  2017 grn    1943 #808e9e  2025 162cm 688706448\r\n3           5  2013 amb    1974 #ceb3a1  2028 191cm 524032739\r\n4           7  2018 grn    1923 #18171d  2021 181cm 777881168\r\n5           8  2016 gry    1941 #a5e1b5  2027 178cm 062495008\r\n6          10  2020 blu    1925 #888785  2023 188cm 117915262\r\n\r\nnrow(valid_p2)\r\n\r\n\r\n[1] 224\r\n\r\n\r\nDay 5\r\nhttps://adventofcode.com/2020/day/5\r\nDay five!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\nInstead of zones or groups, this airline uses binary space partitioning to seat people. A seat might be specified like FBFBBFFRLR, where F means “front”, B means “back”, L means “left”, and R means “right”.\r\nThe first 7 characters will either be F or B; these specify exactly one of the 128 rows on the plane (numbered 0 through 127). Each letter tells you which half of a region the given seat is in. Start with the whole list of rows; the first letter indicates whether the seat is in the front (0 through 63) or the back (64 through 127). The next letter indicates which half of that region the seat is in, and so on until you’re left with exactly one row.\r\nThe last three characters will be either L or R; these specify exactly one of the 8 columns of seats on the plane (numbered 0 through 7). The same process as above proceeds again, this time with only three steps. L means to keep the lower half, while R means to keep the upper half.\r\nSo, decoding FBFBBFFRLR reveals that it is the seat at row 44, column 5.\r\nEvery seat also has a unique seat ID: multiply the row by 8, then add the column. In this example, the seat has ID 44 * 8 + 5 = 357.\r\n\r\nData and Cleaning\r\n\r\n\r\ninput_05 <- read_lines(here(\"2020\",\"day-05.txt\"))\r\n\r\n\r\n\r\nProblem 1: highest seat ID?\r\nFirst, some cleaning.\r\n\r\n\r\nsearch_function <- function(string,range){\r\n  \r\n  midpoint <- length(range)%/%2\r\n  accessor <- str_sub(string,1,1) \r\n\r\n  new_range <- switch(\r\n    accessor,\r\n    \"L\" = ,\r\n    \"F\" = range[1:midpoint],\r\n    \"R\" = ,\r\n    \"B\" = range[-(1:midpoint)])\r\n\r\n  if(length(new_range) == 1) return(new_range)\r\n  \r\n  new_string <- str_remove(string,\"^.\")\r\n  \r\n  search_function(new_string,new_range)\r\n}\r\n\r\nsearch_function(\"FBFBBFF\",0:127)\r\n\r\n\r\n[1] 44\r\n\r\ndf_boardingpasses <- tibble(input = input_05) %>% \r\n  mutate(row_string = str_sub(input,1,7),\r\n         seat_string = str_sub(input,-3,-1),\r\n         row = map_dbl(row_string,search_function,0:127),\r\n         seat = map_dbl(seat_string,search_function,0:7),\r\n         seat_id = row * 8 + seat)\r\n\r\nhead(df_boardingpasses)\r\n\r\n\r\n# A tibble: 6 x 6\r\n  input      row_string seat_string   row  seat seat_id\r\n  <chr>      <chr>      <chr>       <dbl> <dbl>   <dbl>\r\n1 FFBFBBBRLR FFBFBBB    RLR            23     5     189\r\n2 BBFFBFFRRR BBFFBFF    RRR           100     7     807\r\n3 BFFFFBBRRR BFFFFBB    RRR            67     7     543\r\n4 FFBFFBBLRR FFBFFBB    LRR            19     3     155\r\n5 FFBFBFBLLL FFBFBFB    LLL            21     0     168\r\n6 FFBFFBFLRR FFBFFBF    LRR            18     3     147\r\n\r\nmax(df_boardingpasses$seat_id)\r\n\r\n\r\n[1] 818\r\n\r\nProblem 2: Your Seat\r\n\r\nIt’s a completely full flight, so your seat should be the only missing boarding pass in your list. However, there’s a catch: some of the seats at the very front and back of the plane don’t exist on this aircraft, so they’ll be missing from your list as well.\r\nYour seat wasn’t at the very front or back, though; the seats with IDs +1 and -1 from yours will be in your list.\r\n\r\n\r\n\r\nactual_seats <-  df_boardingpasses %>% \r\n  arrange(row,seat) %>% \r\n  filter(\r\n    row != min(row),\r\n    row != max(row)\r\n  )\r\n\r\nx <- seq.int(min(actual_seats$seat_id),max(actual_seats$seat_id))\r\n\r\nx[!(x %in% actual_seats$seat_id)]\r\n\r\n\r\n[1] 559\r\n\r\n\r\nDay 6\r\nhttps://adventofcode.com/2020/day/6\r\nDay six!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\nThe form asks a series of 26 yes-or-no questions marked a through z. All you need to do is identify the questions for which anyone in your group answers “yes”. Since your group is just you, this doesn’t take very long.\r\nHowever, the person sitting next to you seems to be experiencing a language barrier and asks if you can help. For each of the people in their group, you write down the questions for which they answer “yes”, one per line. For example:\r\nabcx\r\nabcy\r\nabcz\r\nIn this group, there are 6 questions to which anyone answered “yes”: a, b, c, x, y, and z. (Duplicate answers to the same question don’t count extra; each question counts at most once.)\r\n\r\nData\r\n\r\n\r\ninput_06 <- read_lines(here(\"2020\",\"day-06.txt\"))\r\n\r\n\r\n\r\nCleaning\r\n\r\n\r\ndf_surveys <- tibble(data = input_06) %>% \r\n  mutate(group_id = ifelse(data == \"\",1,0),\r\n         group_id = cumsum(group_id) + 1) %>% \r\n  filter(data!=\"\") %>% \r\n  mutate(passenger_id = row_number(),\r\n         data = str_split(data,\"\")) %>% \r\n  unnest_longer(data)\r\n\r\n\r\n\r\nProblem 1\r\nFor each group, count the number of questions to which anyone answered “yes”. What is the sum of those counts?\r\n\r\n\r\ndf_surveys %>% \r\n  group_by(group_id) %>% \r\n  summarise(count = length(unique(data))) %>% \r\n  summarise(sum(count))\r\n\r\n\r\n# A tibble: 1 x 1\r\n  `sum(count)`\r\n         <int>\r\n1         6310\r\n\r\nProblem 2\r\nNow count only where everyone in the group answered ALL the same questions.\r\n\r\n\r\ndf_surveys %>% \r\n  group_by(group_id, data) %>%\r\n  mutate(answer_count = n()) %>% \r\n  group_by(group_id) %>%\r\n  mutate(group_count = length(unique(passenger_id))) %>% \r\n  ungroup() %>% \r\n  filter(answer_count == group_count) %>% \r\n  group_by(group_id) %>% \r\n  summarise(count = length(unique(data))) %>% \r\n  summarise(sum(count))\r\n\r\n\r\n# A tibble: 1 x 1\r\n  `sum(count)`\r\n         <int>\r\n1         3193\r\n\r\nNew time PB of fifteen minutes is pretty satisfying!\r\n\r\nDay 7\r\nhttps://adventofcode.com/2020/day/7\r\nDay seven! “Handy Haversacks”\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\nDue to recent aviation regulations, many rules (your puzzle input) are being enforced about bags and their contents; bags must be color-coded and must contain specific quantities of other color-coded bags. Apparently, nobody responsible for these regulations considered how long they would take to enforce!\r\nFor example, consider the following rules:\r\nlight red bags contain 1 bright white bag, 2 muted yellow bags.\r\ndark orange bags contain 3 bright white bags, 4 muted yellow bags.\r\nbright white bags contain 1 shiny gold bag.\r\nmuted yellow bags contain 2 shiny gold bags, 9 faded blue bags.\r\nshiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.\r\ndark olive bags contain 3 faded blue bags, 4 dotted black bags.\r\nvibrant plum bags contain 5 faded blue bags, 6 dotted black bags.\r\nfaded blue bags contain no other bags.\r\ndotted black bags contain no other bags.\r\nThese rules specify the required contents for 9 bag types. In this example, every faded blue bag is empty, every vibrant plum bag contains 11 bags (5 faded blue and 6 dotted black), and so on.\r\nYou have a shiny gold bag. If you wanted to carry it in at least one other bag, how many different bag colors would be valid for the outermost bag? (In other words: how many colors can, eventually, contain at least one shiny gold bag?)\r\nIn the above rules, the following options would be available to you:\r\nA bright white bag, which can hold your shiny gold bag directly.\r\nA muted yellow bag, which can hold your shiny gold bag directly, plus some other bags.\r\nA dark orange bag, which can hold bright white and muted yellow bags, either of which could then hold your shiny gold bag.\r\nA light red bag, which can hold bright white and muted yellow bags, either of which could then hold your shiny gold bag.\r\nSo, in this example, the number of bag colors that can eventually contain at least one shiny gold bag is 4.\r\nHow many bag colors can eventually contain at least one shiny gold bag?\r\n\r\nData\r\n\r\n\r\ninput_07 <- read_lines(here(\"2020\",\"day-07.txt\"))\r\n\r\n\r\n\r\nCleaning\r\n\r\n\r\ndf_rules <- tibble(input = input_07) %>% \r\n  separate(input,into = c(\"name\",\"rule\"),sep = \" bags contain \") %>% \r\n  mutate(rule = str_split(rule,\"bags|bag\")) %>% \r\n  unnest_longer(rule)  %>% \r\n  mutate(rule = str_remove(rule,\",\"),\r\n         rule = str_remove(rule,\"\\\\.\"),\r\n         rule = str_squish(rule)) %>% \r\n  filter(rule != \"\") %>% \r\n  mutate(rule_qty = parse_number(rule,na = \"no other\"),\r\n         rule_colour = if_else(is.na(rule_qty), \r\n                               NA_character_,\r\n                               str_remove(rule,as.character(rule_qty))),\r\n         rule_colour = str_squish(rule_colour))\r\n\r\n\r\n\r\nProblem 1 - how many bag colours eventually contain one shiny gold bag?\r\n\r\n\r\nfind_parents <- function(colour,df_rules){\r\n  \r\n  x <- df_rules %>% \r\n    filter(rule_colour == colour, rule_qty >= 1)\r\n  \r\n  map_dfr(x$name,find_parents,df_rules) %>% \r\n    bind_rows(x,.)\r\n  \r\n}\r\n\r\nparents <- find_parents(\"shiny gold\",df_rules)\r\n\r\nunique(parents$name) %>% length()\r\n\r\n\r\n[1] 119\r\n\r\nProblem 2 - how many bags are inside your shiny gold bag?\r\nThe ultimate “I’m too tired for this shit” move is to pull out parallel processing on it. Cause ugh.\r\n\r\n\r\nlibrary(furrr) \r\n\r\nplan(multiprocess)\r\n\r\nfind_children <- function(colour,df_rules){\r\n  \r\n  x <- df_rules %>% \r\n    filter(name == colour,!is.na(rule_qty))\r\n  \r\n  if(nrow(x)==0) return(tibble())\r\n  \r\n  x <- x %>% \r\n    mutate(rule_colour = map2(rule_colour,rule_qty,rep_len)) %>% \r\n    unnest_longer(rule_colour)\r\n  \r\n  y <- future_map_dfr(x$rule_colour,find_children,df_rules)\r\n  \r\n  bind_rows(x,y)\r\n}\r\n\r\nchildren <- find_children(\"shiny gold\",df_rules)\r\n\r\n\r\n\r\n\r\n\r\nnrow(children)\r\n\r\n\r\n[1] 155802\r\n\r\n\r\nDay 8\r\nhttps://adventofcode.com/2020/day/8\r\nDay eight! “Handheld Halting”\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\nThe boot code is represented as a text file with one instruction per line of text. Each instruction consists of an operation (acc, jmp, or nop) and an argument (a signed number like +4 or -20).\r\nacc increases or decreases a single global value called the accumulator by the value given in the argument. For example, acc +7 would increase the accumulator by 7. The accumulator starts at 0. After an acc instruction, the instruction immediately below it is executed next.\r\njmp jumps to a new instruction relative to itself. The next instruction to execute is found using the argument as an offset from the jmp instruction; for example, jmp +2 would skip the next instruction, jmp +1 would continue to the instruction immediately below it, and jmp -20 would cause the instruction 20 lines above to be executed next.\r\nnop stands for No OPeration - it does nothing. The instruction immediately below it is executed next.\r\nThis is an infinite loop: with this sequence of jumps, the program will run forever. The moment the program tries to run any instruction a second time, you know it will never terminate.\r\nImmediately before the program would run an instruction a second time, the value in the accumulator is 5.\r\nRun your copy of the boot code. Immediately before any instruction is executed a second time, what value is in the accumulator?\r\n\r\nData\r\n\r\n\r\ninput_08 <- read_lines(here(\"2020\",\"day-08.txt\"))\r\n\r\n\r\n\r\nCleaning\r\n\r\n\r\ndf_codes <- tibble(x = input_08) %>% \r\n  separate(x,c(\"instruction\",\"qty\"),sep = \" \", convert = TRUE) %>% \r\n  mutate(instruction_id = row_number(),\r\n         next_instruction_id = case_when(instruction == \"jmp\" ~ instruction_id + qty,\r\n                                         TRUE ~ instruction_id + 1L)) %>% \r\n  select(instruction_id,instruction,qty,next_instruction_id)\r\n\r\n\r\n\r\nProblem 1: Immediately before any instruction is executed a second time, what value is in the accumulator?\r\n\r\n\r\ncurrent_id <- 1\r\naccumulator <- 0\r\nerror_switch <- FALSE\r\nvisited_codes <- tibble()\r\n\r\nwhile(!error_switch){\r\n  \r\n  current_instruction <- df_codes %>% \r\n    filter(instruction_id == current_id)\r\n  \r\n  visited_codes <- bind_rows(visited_codes,current_instruction)\r\n  \r\n  if(current_instruction$instruction == \"acc\") accumulator <- accumulator + current_instruction$qty\r\n  \r\n  current_id <- current_instruction$next_instruction_id\r\n  \r\n  if(current_id %in% visited_codes$instruction_id) error_switch <- TRUE\r\n\r\n}\r\n\r\naccumulator\r\n\r\n\r\n[1] 1797\r\n\r\nProblem 2: Fix the program\r\nThe program has a bug where one of jmp or nop are wrong and should be the other way around, which will let the program run all of the rows. If the program exits correctly, what is the accumulator total?\r\nFirst, create function for accumulator.\r\n\r\n\r\nrun_accumulator <- function(df_codes){\r\n  \r\n  current_id <- 1\r\n  accumulator <- 0\r\n  error_switch <- FALSE\r\n  visited_codes <- tibble()\r\n  status <- \"FAIL\"\r\n  \r\n  while(!error_switch){\r\n    \r\n    current_instruction <- df_codes %>% \r\n      filter(instruction_id == current_id)\r\n    \r\n    visited_codes <- bind_rows(visited_codes,current_instruction)\r\n    \r\n    if(current_instruction$instruction == \"acc\") accumulator <- accumulator + current_instruction$qty\r\n    \r\n    current_id <- current_instruction$next_instruction_id\r\n    \r\n    if(current_id == 626) error_switch <- TRUE\r\n    \r\n    if(current_id %in% visited_codes$instruction_id) error_switch <- TRUE\r\n  }\r\n\r\n  if(current_id == 626) status <- \"SUCCESS\"\r\n  \r\n  return( \r\n    list(\r\n      status = status, \r\n      accumulator = accumulator, \r\n      next_id = current_id)\r\n  )\r\n}\r\n\r\nrun_accumulator(df_codes)\r\n\r\n\r\n$status\r\n[1] \"FAIL\"\r\n\r\n$accumulator\r\n[1] 1797\r\n\r\n$next_id\r\n[1] 606\r\n\r\nNext, build function to switch jmp and nop, build list of dfs, run the accumulator on it and find success.\r\n\r\n\r\nlibrary(furrr)\r\n\r\nplan(multisession)\r\n\r\njmpnop_switcher <- function(id,df_codes){\r\n  \r\n  df_codes$instruction[id] <- switch(df_codes$instruction[id],\r\n                                     \"jmp\" = \"nop\",\r\n                                     \"nop\" = \"jmp\")\r\n  \r\n  df_codes <- df_codes %>% \r\n    mutate(next_instruction_id = case_when(instruction == \"jmp\" ~ instruction_id + qty,\r\n                                           TRUE ~ instruction_id + 1L))\r\n  \r\n  df_codes\r\n}\r\n\r\njmpnop_list <- df_codes$instruction_id[df_codes$instruction %in% c(\"jmp\",\"nop\")]\r\n\r\ndf_codelist <- map(jmpnop_list,jmpnop_switcher,df_codes)\r\n\r\nx <- future_map_dfr(df_codelist,run_accumulator)\r\n\r\nx %>% arrange(desc(status))\r\n\r\n\r\n# A tibble: 298 x 3\r\n   status  accumulator next_id\r\n   <chr>         <dbl>   <int>\r\n 1 SUCCESS        1036     626\r\n 2 FAIL           1818     448\r\n 3 FAIL           1797     606\r\n 4 FAIL           1797     606\r\n 5 FAIL           1797     606\r\n 6 FAIL           1797     606\r\n 7 FAIL           1797     606\r\n 8 FAIL           1797     606\r\n 9 FAIL            726     606\r\n10 FAIL            682     606\r\n# ... with 288 more rows\r\n\r\n\r\nDay 9\r\nhttps://adventofcode.com/2020/day/9\r\nDay nine - encoding error!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n— Description —\r\n\r\nXMAS starts by transmitting a preamble of 25 numbers. After that, each number you receive should be the sum of any two of the 25 immediately previous numbers. The two numbers will have different values, and there might be more than one such pair.\r\nFor example, suppose your preamble consists of the numbers 1 through 25 in a random order. To be valid, the next number must be the sum of two of those numbers.\r\nThe first step of attacking the weakness in the XMAS data is to find the first number in the list (after the preamble) which is not the sum of two of the 25 numbers before it. What is the first number that does not have this property?\r\n\r\n— Data —\r\n\r\n\r\ninput_09 <- read_lines(here(\"2020\",\"day-09.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\nOffhand, I’m going to use Davis Vaughan’s slider package to create the rolling windows for each row, and then tackle it for each problem.\r\n\r\n\r\nlibrary(slider)\r\n\r\ndf_cipher <- tibble(num = input_09) %>% \r\n  mutate_all(as.numeric) %>% \r\n  mutate(rolling = slide(num,~.x,.before = 24, .complete = TRUE) %>% lag()) %>% \r\n  slice(-(1:25))\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\nFind the first number which is not the sum of the two numbers before it.\r\n\r\n\r\n\r\nproblem_1 <- df_cipher %>% \r\n  mutate(rolling_sum = map2_lgl(rolling,num, \r\n                                ~ crossing(x = .x, y = .x) %>% \r\n                                  mutate(sum = x + y,\r\n                                         flag = sum == .y) %>% \r\n                                  summarise(flag = any(flag)) %>% \r\n                                  pull(flag)))\r\n\r\nproblem_1 %>% \r\n  filter(!rolling_sum)\r\n\r\n\r\n# A tibble: 1 x 3\r\n       num rolling    rolling_sum\r\n     <dbl> <list>     <lgl>      \r\n1 10884537 <dbl [25]> FALSE      \r\n\r\nsolution_1 <- problem_1 %>% \r\n  filter(!rolling_sum) %>% \r\n  pull(num)\r\n\r\n\r\n\r\n— Problem 2 —\r\n\r\nThe final step in breaking the XMAS encryption relies on the invalid number you just found: you must find a contiguous set of at least two numbers in your list which sum to the invalid number from step 1.\r\n\r\nBack to slider again, this time using a loop to iterate the size of the rolling window upward until the solution is found.\r\n\r\n\r\nproblem_2 <- df_cipher %>% \r\n  filter(num < solution_1) %>%\r\n  select(num)\r\n\r\nsuccess <- FALSE\r\nsize <- 1\r\n\r\nwhile(!success){\r\n  size <- size + 1\r\n  \r\n  test_solve <- problem_2 %>% \r\n    mutate(rolling_sum = slide_dbl(num,sum,.complete = TRUE,.before = size - 1),\r\n           success = rolling_sum == solution_1)\r\n  \r\n  success <- any(test_solve$success,na.rm = TRUE)\r\n}\r\n\r\ncleanup_solution <- test_solve %>% \r\n  slice((which(test_solve$success)-size+1):which(test_solve$success))\r\n  \r\nmin(cleanup_solution$num) + max(cleanup_solution$num)\r\n\r\n\r\n[1] 1261309\r\n\r\n\r\nDay 10\r\nhttps://adventofcode.com/2020/day/10\r\nDay ten - Adapter Array!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n})\r\n\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\nFind a chain that uses all of your adapters to connect the charging outlet to your device’s built-in adapter and count the joltage differences between the charging outlet, the adapters, and your device. What is the number of 1-jolt differences multiplied by the number of 3-jolt differences?\r\n\r\n— Data —\r\n\r\n\r\ninput_10 <- read_lines(here(\"2020\",\"day-10.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\ndf_adapters <- tibble(adapter = input_10) %>% \r\n  mutate(adapter = as.numeric(adapter)) %>% \r\n  add_row(adapter = max(.$adapter)+3) %>% \r\n  arrange(adapter) %>% \r\n  mutate(diff = adapter - lag(adapter,default = 0))\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\np1 <- df_adapters %>% \r\n  count(diff)\r\n\r\nprod(p1$n)\r\n\r\n\r\n[1] 2263\r\n\r\n— Problem 2 —\r\nWhat is the total number of distinct ways you can arrange the adapters to connect the charging outlet to your device?\r\n\r\n\r\nlibrary(slider)\r\noptions(scipen = 999)\r\n\r\np2 <- df_adapters %>%\r\n  select(adapter) %>%\r\n  add_row(adapter = 0) %>% \r\n  arrange(desc(adapter)) %>% \r\n  mutate(\r\n    ways = slide(adapter,~.x,.before = 3,.after = -1),\r\n    ways = map2(ways,adapter,~.x[.x-.y<=3]))\r\n\r\nlookup_table <- numeric()\r\nlookup_table[[max(df_adapters$adapter)]] <- 1 # seed lookup_table for 166 as 1 path\r\n\r\np2 <- p2 %>% slice(-1) # remove 166, ways you can plug 166 in is blank\r\n\r\nsum_ways <- function(ways,adapter){\r\n  \r\n  ways <- unlist(ways)\r\n  \r\n  total_ways <- sum(lookup_table[ways]) # read lookup table for each of the ways\r\n    \r\n  lookup_table[adapter] <<- total_ways # superassign into lookup table the total ways for this adapter\r\n  \r\n  return(total_ways)\r\n}\r\n\r\np2_solve <- p2 %>% \r\n  mutate(total_ways = map2_dbl(ways,adapter,sum_ways))\r\n\r\nmax(p2_solve$total_ways)\r\n\r\n\r\n[1] 396857386627072\r\n\r\n\r\nDay 11\r\nhttps://adventofcode.com/2020/day/11\r\nDay eleven - seating system!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(furrr)\r\n  library(memoise)\r\n  \r\n  plan(multisession)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nAll decisions are based on the number of occupied seats adjacent to a given seat (one of the eight positions immediately up, down, left, right, or diagonal from the seat). The following rules are applied to every seat simultaneously:\r\n\r\n\r\nIf a seat is empty (L) and there are no occupied seats adjacent to it, the seat becomes occupied. If a seat is occupied (#) and four or more seats adjacent to it are also occupied, the seat becomes empty. Otherwise, the seat’s state does not change.\r\n\r\n— Data —\r\n\r\n\r\ninput_11 <- read_lines(here(\"2020\",\"day-11.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\nseat_map <- tibble(col = input_11) %>% \r\n  mutate(col = str_split(col,\"\")) %>% \r\n  unnest_wider(col,names_sep = \"_\") %>% \r\n  mutate_all(~replace(.x,.x == \".\",NA)) %>% \r\n  mutate_all(~replace(.x,.x == \"L\",0)) %>% \r\n  mutate_all(as.numeric)\r\n\r\nseat_matrix <- as.matrix(seat_map)\r\n\r\nseat_index <- seat_map %>% \r\n  rownames_to_column(var = \"row_index\") %>% \r\n  mutate(row_index = as.numeric(row_index)) %>% \r\n  pivot_longer(cols = -row_index,names_to = \"column_index\") %>% \r\n  mutate(column_index = parse_number(column_index))\r\n\r\n\r\n\r\nFunctions\r\n\r\n\r\ngenerate_adjacent <- function(row_index,column_index,seat_matrix){\r\n  \r\n  check <- seat_matrix[[row_index,column_index]]\r\n  \r\n  if(is.na(check)) return(NA)\r\n  \r\n  r <- c(row_index - 1, row_index, row_index + 1)\r\n  c <- c(column_index -1, column_index, column_index + 1)\r\n  \r\n  x <- expand_grid(row = r,col = c) %>% \r\n    filter(!(row==row_index & col==column_index)) %>% \r\n    filter(between(row,1,nrow(seat_matrix)),between(col,1,ncol(seat_matrix))) %>% \r\n    mutate(value = map2_dbl(row,col,~seat_matrix[[.x,.y]])) %>% \r\n    filter(!is.na(value))\r\n    \r\n  return(x)\r\n}\r\n\r\nget_seat <- function(row,col,p1){\r\n  p1[[row, col]]\r\n}\r\n\r\ncount_occupied <- function(adjacent_seats,p1){\r\n\r\n  if(is.logical(adjacent_seats)) return(NA)\r\n  \r\n  x <- adjacent_seats %>% \r\n    mutate(value = map2_dbl(.data$row,.data$col,get_seat,p1))\r\n  \r\n  sum(x$value,na.rm = TRUE)\r\n}\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\nSimulate your seating area by applying the seating rules repeatedly until no seats change state. How many seats end up occupied?\r\n\r\n\r\n\r\np1_index <- seat_index %>% \r\n  mutate(adjacent_seats = future_map2(row_index,column_index,generate_adjacent,seat_matrix))\r\n\r\np1 <- seat_matrix\r\ntotal_value <- sum(p1,na.rm = TRUE)\r\ntotal_change <- 1\r\niteration <- 1\r\nlist_changes <- c()\r\n\r\nwhile(total_change!=0){\r\n  \r\n  p1_index <- p1_index %>% \r\n    mutate(adjacent_status = future_map_dbl(adjacent_seats,count_occupied,p1),\r\n           value = case_when(adjacent_status == 0 ~ 1,\r\n                              adjacent_status >=4 ~ 0,\r\n                              TRUE ~ value))\r\n  \r\n  p1 <- matrix(p1_index$value,nrow = nrow(seat_matrix), ncol = ncol(seat_matrix), byrow=TRUE)\r\n  \r\n  change <- sum(p1,na.rm = TRUE)\r\n  total_change <- change - total_value\r\n  total_value <- change\r\n  \r\n  list_changes <- c(list_changes,change)\r\n  \r\n  iteration <- iteration + 1\r\n  \r\n  print(iteration)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\nchange # last change\r\n\r\n\r\n[1] 2243\r\n\r\n— Problem 2 —\r\n\r\nPeople don’t just care about adjacent seats - they care about the first seat they can see in each of those eight directions!\r\n\r\nSo rewrite the adjacent seats function first, then rerun the loop and get seats etc. Trying matrices for faster speed.\r\nFunctions\r\n\r\n\r\ngen_los <- function(row_dir,col_dir,row_index,col_index,row_max,col_max,seat_matrix){\r\n  if(!between(row_index + row_dir,1,row_max)) return(NULL)\r\n  if(!between(col_index + col_dir,1,col_max)) return(NULL)\r\n  \r\n  value <- seat_matrix[[row_index + row_dir,col_index + col_dir]]\r\n  \r\n  if(!is.na(value)) return(list(row = row_index + row_dir, col = col_index + col_dir))\r\n  \r\n  new_rowindex <- row_index + row_dir\r\n  new_colindex <- col_index + col_dir\r\n  \r\n  gen_los(row_dir,col_dir,new_rowindex,new_colindex,row_max,col_max,seat_matrix)\r\n}\r\n\r\ngenerate_los <- function(row_index,column_index,seat_matrix){\r\n  \r\n  check <- seat_matrix[row_index,column_index]\r\n  \r\n  if(is.na(check)) return(NA)\r\n  \r\n  r <- c(-1, 0, 1)\r\n  c <- c(-1, 0, 1)\r\n  \r\n  x <- expand_grid(row = r,col = c) %>% \r\n    filter(!(row == 0 & col == 0))\r\n  \r\n  y <- map2_dfr(x$row,x$col,gen_los,row_index,column_index,nrow(seat_matrix),ncol(seat_matrix),seat_matrix)\r\n  \r\n  return(y)\r\n}\r\n\r\n# get_seat2 <- memoise::memoise(get_seat2,cache = cache_filesystem(here(\"2020/day-11-cache\")))\r\n\r\nget_seat2 <- function(row,col,iteration){\r\n  p2[row,col]\r\n}\r\n\r\ncount_occupied2 <- function(adjacent_seats,iteration){\r\n  \r\n  if(is.logical(adjacent_seats)) return(NA)\r\n  \r\n  x <- map2_dbl(adjacent_seats$row,adjacent_seats$col,get_seat2,iteration) \r\n  \r\n  sum(x,na.rm = TRUE)\r\n}\r\n\r\n\r\n\r\n\r\n\r\np2_index <- seat_index %>% \r\n  mutate(row_index = as.numeric(row_index),\r\n         adjacent_seats = future_map2(row_index,column_index,generate_los,seat_matrix))\r\n\r\n\r\n\r\n\r\n\r\np2 <- seat_matrix\r\ntotal_value2 <- sum(p2,na.rm = TRUE)\r\ntotal_change2 <- 1\r\niteration2 <- 1\r\nlist_changes2 <- c()\r\n\r\nwhile(total_change2!=0){\r\n  \r\n  p2_index <- p2_index %>% \r\n    mutate(adjacent_status = future_map_dbl(adjacent_seats,count_occupied2,iteration2),\r\n           value = case_when(adjacent_status == 0 ~ 1,\r\n                             adjacent_status >=5 ~ 0,\r\n                             TRUE ~ value))\r\n  \r\n  p2 <- matrix(p2_index$value,nrow = nrow(seat_matrix), ncol = ncol(seat_matrix), byrow=TRUE)\r\n  \r\n  change2 <- sum(p2,na.rm = TRUE)\r\n  total_change2 <- change2 - total_value2\r\n  total_value2 <- change2\r\n  \r\n  list_changes2 <- c(list_changes2,change2)\r\n  \r\n  iteration2 <- iteration2 + 1\r\n  \r\n  print(iteration2)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\nchange2\r\n\r\n\r\n[1] 2027\r\n\r\n\r\nDay 12\r\nhttps://adventofcode.com/2020/day/12\r\nDay twelve - Rain Risk!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  # library(slider)\r\n  # library(furrr)\r\n  # library(memoise)\r\n  \r\n  # plan(multisession)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nThe navigation instructions (your puzzle input) consists of a sequence of single-character actions paired with integer input values. After staring at them for a few minutes, you work out what they probably mean:\r\nAction N means to move north by the given value.\r\nAction S means to move south by the given value.\r\nAction E means to move east by the given value.\r\nAction W means to move west by the given value.\r\nAction L means to turn left the given number of degrees.\r\nAction R means to turn right the given number of degrees.\r\nAction F means to move forward by the given value in the direction the ship is currently facing.\r\n\r\n— Data —\r\n\r\n\r\ninput_12 <- read_lines(here(\"2020\",\"day-12.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\ninstructions <- tibble(instruction = input_12) %>%\r\n  extract(instruction,into = c(\"instruction\",\"num\"),regex = \"^([A-z])([0-9]+)\",convert = TRUE)\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\nFigure out where the navigation instructions lead. What is the Manhattan distance between that location and the ship’s starting position?\r\n\r\nSetting out some functions.\r\n\r\n\r\nmove_nesw1 <- function(direction,value,current_position){\r\n  \r\n  switch(direction,\r\n         \"N\" = current_position$y <- current_position$y + value,\r\n         \"E\" = current_position$x <- current_position$x + value,\r\n         \"S\" = current_position$y <- current_position$y - value,\r\n         \"W\" = current_position$x <- current_position$x - value\r\n         )\r\n  return(current_position)\r\n}\r\n\r\nmove_lr1 <- function(direction,value,current_position){\r\n  switch(direction,\r\n         \"L\" = current_position$direction <- current_position$direction + value,\r\n         \"R\" = current_position$direction <- current_position$direction - value)\r\n  \r\n  if(current_position$direction >= 360) current_position$direction <- current_position$direction %% 360\r\n  \r\n  if(current_position$direction < 0) current_position$direction <- current_position$direction + 360\r\n  \r\n  return(current_position)\r\n}\r\n\r\nmove_fb1 <- function(value,current_position){\r\n  \r\n  dir <- current_position$direction %>% as.character \r\n  \r\n  switch (dir,\r\n    '0' = current_position$x <- current_position$x + value,\r\n    '90' = current_position$y <- current_position$y + value,\r\n    '180' = current_position$x <- current_position$x - value,\r\n    '270' = current_position$y <- current_position$y - value\r\n  )\r\n  \r\n  return(current_position)\r\n}\r\n\r\ndecide_move1 <- function(current_position,direction,value){\r\n  \r\n  switch(direction,\r\n         \"L\" = ,\r\n         \"R\" = move_lr1(direction,value,current_position),\r\n         \"F\" = move_fb1(value,current_position),\r\n         \"N\" = ,\r\n         \"E\" = ,\r\n         \"S\" = ,\r\n         \"W\" = move_nesw1(direction,value,current_position))\r\n}\r\n\r\n\r\n\r\nNow run through the instructions:\r\n\r\n\r\ncurrent_position <- list(\r\n  direction = 0, # where 0 = East\r\n  x = 0,\r\n  y = 0\r\n)\r\npositions <- current_position\r\n\r\nfor(i in seq_len(nrow(instructions))){\r\n\r\n  new_position <- decide_move1(current_position,instructions$instruction[[i]],instructions$num[[i]])\r\n  \r\n  positions <- bind_rows(positions,new_position)\r\n  \r\n  current_position <- new_position\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncurrent_position\r\n\r\n\r\n$direction\r\n[1] 90\r\n\r\n$x\r\n[1] -397\r\n\r\n$y\r\n[1] -399\r\n\r\nabs(current_position$x) + abs(current_position$y)\r\n\r\n\r\n[1] 796\r\n\r\n— Problem 2 —\r\n\r\nFigure out where the navigation instructions actually lead. What is the Manhattan distance between that location and the ship’s starting position?\r\n\r\nRewriting previous functions:\r\n\r\n\r\nmove_waypoint_nesw <- function(direction,value,current_position){\r\n  \r\n  switch(direction,\r\n         \"N\" = current_position$waypoint_y <- current_position$waypoint_y + value,\r\n         \"E\" = current_position$waypoint_x <- current_position$waypoint_x + value,\r\n         \"S\" = current_position$waypoint_y <- current_position$waypoint_y - value,\r\n         \"W\" = current_position$waypoint_x <- current_position$waypoint_x - value\r\n         )\r\n  return(current_position)\r\n}\r\n\r\nmove_waypoint_lr <- function(direction,value,current_position){\r\n\r\n  new_position <- current_position\r\n  \r\n  if(value == 90){\r\n    if(direction == \"L\"){\r\n      new_position$waypoint_x <- current_position$waypoint_y * -1\r\n      new_position$waypoint_y <- current_position$waypoint_x\r\n    }\r\n    if(direction == \"R\"){\r\n      new_position$waypoint_x <- current_position$waypoint_y \r\n      new_position$waypoint_y <- current_position$waypoint_x * -1\r\n    }\r\n  }\r\n  \r\n  if(value == 180){\r\n    new_position$waypoint_x <- current_position$waypoint_x * -1\r\n    new_position$waypoint_y <- current_position$waypoint_y * -1\r\n  }\r\n  \r\n  if(value == 270){\r\n    if(direction == \"R\"){\r\n      new_position$waypoint_x <- current_position$waypoint_y * -1\r\n      new_position$waypoint_y <- current_position$waypoint_x\r\n    }\r\n    if(direction == \"L\"){\r\n      new_position$waypoint_x <- current_position$waypoint_y \r\n      new_position$waypoint_y <- current_position$waypoint_x * -1\r\n    }\r\n  }\r\n  \r\n  return(new_position)\r\n}\r\n\r\nmove_fb_waypoint <- function(value,current_position){\r\n  \r\n  dir <- current_position$direction %>% as.character \r\n  \r\n  current_position$ship_x <- current_position$ship_x + (value * current_position$waypoint_x)\r\n  current_position$ship_y <- current_position$ship_y + (value * current_position$waypoint_y)\r\n  \r\n  return(current_position)\r\n}\r\n\r\ndecide_move2 <- function(current_position,direction,value){\r\n  \r\n  switch(direction,\r\n         \"L\" = ,\r\n         \"R\" = move_waypoint_lr(direction,value,current_position),\r\n         \"N\" = ,\r\n         \"E\" = ,\r\n         \"S\" = ,\r\n         \"W\" = move_waypoint_nesw(direction,value,current_position),\r\n         \"F\" = move_fb_waypoint(value,current_position)\r\n  )\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncurrent_position <- list(\r\n  waypoint_x = 10,\r\n  waypoint_y = 1,\r\n  ship_x = 0,\r\n  ship_y = 0\r\n)\r\n\r\npositions <- current_position\r\n\r\nfor(i in seq_len(nrow(instructions))){\r\n\r\n  new_position <- decide_move2(current_position,instructions$instruction[[i]],instructions$num[[i]])\r\n  \r\n  positions <- bind_rows(positions,new_position)\r\n  \r\n  current_position <- new_position\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncurrent_position\r\n\r\n\r\n$waypoint_x\r\n[1] 26\r\n\r\n$waypoint_y\r\n[1] 37\r\n\r\n$ship_x\r\n[1] -24417\r\n\r\n$ship_y\r\n[1] -15029\r\n\r\nabs(current_position$ship_x) + abs(current_position$ship_y)\r\n\r\n\r\n[1] 39446\r\n\r\n\r\nDay 13\r\nhttps://adventofcode.com/2020/day/13\r\nDay thirteen - shuttle search!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  library(httr)\r\n\r\n  # plan(multisession)\r\n  options(scipen  =  9999999)\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nYour notes (your puzzle input) consist of two lines. The first line is your estimate of the earliest timestamp you could depart on a bus. The second line lists the bus IDs that are in service according to the shuttle company; entries that show x must be out of service, so you decide to ignore them.\r\nTo save time once you arrive, your goal is to figure out the earliest bus you can take to the airport. (There will be exactly one such bus.)\r\n\r\n— Data —\r\n\r\n\r\ninput_13 <- read_lines(here(\"2020\",\"day-13.txt\"))\r\n\r\ninput_13_e <- c(\"939\",\"7,13,x,x,59,x,31,19\")\r\n\r\n\r\n\r\n—Cleaning—\r\n\r\n\r\nearliest_timestamp <- input_13[[1]] %>% as.numeric\r\n\r\nearliest_timestamp_e <- input_13_e[[1]] %>% as.numeric\r\n\r\nbus_departures <- tibble(id = input_13[[2]]) %>% \r\n  separate_rows(id,sep = \",\")\r\n\r\nbus_departures_e <- tibble(id = input_13_e[[2]]) %>% \r\n  separate_rows(id,sep = \",\")\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\np1 <- bus_departures %>% \r\n  filter(id != \"x\") %>% \r\n  mutate(id = as.numeric(id)) %>% \r\n  mutate(next_departure = earliest_timestamp %/% id * id,\r\n         next_departure = case_when(earliest_timestamp > next_departure ~ next_departure + id,\r\n                                    TRUE ~ next_departure)) %>% \r\n  arrange(next_departure)\r\n\r\n\r\n\r\n\r\n\r\nhead(p1)\r\n\r\n\r\n# A tibble: 6 x 2\r\n     id next_departure\r\n  <dbl>          <dbl>\r\n1   647        1006732\r\n2    23        1006733\r\n3    13        1006733\r\n4    37        1006733\r\n5    19        1006734\r\n6    29        1006735\r\n\r\np1$id[[1]] * (p1$next_departure[[1]] - earliest_timestamp)\r\n\r\n\r\n[1] 3882\r\n\r\n— Problem 2 —\r\n\r\n\r\np2 <- bus_departures %>% \r\n  mutate(offset = row_number()-1) %>% \r\n  filter(id != \"x\") %>% \r\n  mutate(id = as.numeric(id))\r\n\r\n\r\n\r\nMy naive solution looked like this:\r\n\r\n\r\nrun_checks <- function(timestamp,id,offset){\r\n  sum((timestamp+offset) %% id)\r\n}\r\n\r\nbiggest_factor <- max(p2$id)\r\n\r\ntimestamp <- 100000000000000 %/% biggest_factor * biggest_factor\r\n\r\nsum <- 1\r\n\r\nwhile(sum!=0){\r\n  timestamp <- timestamp+biggest_factor\r\n  sum <- run_checks(timestamp,p2$id,p2$offset)\r\n}\r\n\r\ntimestamp\r\n\r\n\r\n\r\nWhile I was waiting for the first loop, I started reading solutions in other languages. I’m admittedly getting a little out of my depth, and noticed a) people talking about the naive/brute-force solution being incredibly slow even in a language like C, b) how many people looked up and implemented Chinese Remainder Theorem (some math concept I’d never heard of) and c) how many people just copied their problem into an online solver.\r\nI don’t have the math chops to teach myself CRT at 1:30 am, so I decided to look around at some other options.\r\nFirstly, trying the {numbers} package I found on CRAN, which professed to have a chinese() function.\r\n\r\n\r\nlibrary(numbers)\r\noptions(scipen = 999)\r\n\r\nchinese(p2$offset,p2$id)\r\n\r\n\r\n\r\n\r\n[1] 663851081414962\r\n\r\nThis … seemed … promising - but failed to pass muster as the solution.\r\nI futzed with this, thinking that I’d done it wrong and set things up incorrectly - but alas, no dice.\r\nNext, Reddit suggested Rosetta Code as a place to get functions in any programming language for CRT, so I toyed with that:\r\n\r\n\r\nmul_inv <- function(a, b)\r\n{\r\n  b0 <- b\r\n  x0 <- 0L\r\n  x1 <- 1L\r\n \r\n  if (b == 1) return(1L)\r\n  while(a > 1){\r\n    q <- a/b\r\n \r\n    t <- b\r\n    b <- a %% b\r\n    a <- t\r\n \r\n    t <- x0\r\n    x0 <- x1 - q*x0\r\n    x1 <- t\r\n  }\r\n \r\n  if (x1 < 0) x1 <- x1 + b0\r\n  return(x1)\r\n}\r\n \r\nchinese_remainder <- function(n, a)\r\n{\r\n  len <- length(n)\r\n \r\n  prod <- 1L\r\n  sum <- 0L\r\n \r\n  for (i in 1:len) prod <- prod * n[i]\r\n \r\n  for (i in 1:len){\r\n    p <- prod / n[i]\r\n    sum <- sum + a[i] * mul_inv(p, n[i]) * p\r\n  }\r\n \r\n  return(sum %% prod)\r\n}\r\n \r\nn <- p2$id\r\na <- p2$offset\r\n \r\nchinese_remainder(n, a)\r\n\r\n\r\n\r\n\r\n[1] 502023422045264\r\n\r\nbut also no dice. I figure it’s reaching R’s bigint limits, or something, and causing rounding/float errors.\r\nFinally, I resorted to just getting old faithful, Wolfram Alpha, to solve the system of equations.\r\nI’m an honorable cheat though: I figured I’d limit myself to learning and using the Wolfram Alpha API instead.\r\nHere’s some of my standard set of packages for interacting with APIs:\r\n\r\n\r\nlibrary(httr)\r\nlibrary(glue)\r\nlibrary(xml2)\r\nlibrary(rvest)\r\n\r\n\r\n\r\nYou need to sign up for an API app ID, which is free but limited to 2000 queries per month. https://products.wolframalpha.com/api\r\nI’ve got my apikey saved as a system environment variable, there are other ways to handle the secret (rstudioapi, keyring, etc)\r\n\r\n\r\napikey <- Sys.getenv(\"wolfram_alpha\")\r\n\r\n\r\n\r\nCreate the system of equations and reduce it into a single comma separated string\r\n\r\n\r\nequations <- glue::glue(\"(x + {p2$offset}) mod {p2$id}=0\") %>% paste(collapse = \",\")\r\n\r\n\r\n\r\nSend the equations and the apikey as html query parameters in a GET request\r\n\r\n\r\nresponse <- httr::GET(\"http://api.wolframalpha.com/v2/query\",\r\n               query = list(input = equations,\r\n                            appid = apikey))\r\n\r\n\r\n\r\nParse the response, drilling down to the plaintext.\r\n\r\n\r\nresp_content <- content(response,as = \"parsed\")\r\n\r\nplaintext <- resp_content %>% \r\n  html_nodes(\"plaintext\") %>% \r\n  html_text()\r\n\r\n\r\n\r\n\r\n\r\nplaintext \r\n\r\n\r\n[1] \"{(x + 0) mod 23 = 0, (x + 13) mod 41 = 0, (x + 23) mod 647 = 0, (x + 41) mod 13 = 0, (x + 42) mod 19 = 0, (x + 52) mod 29 = 0, (x + 54) mod 557 = 0, (x + 60) mod 37 = 0, (x + 71) mod 17 = 0}\"                                                                                                                                \r\n[2] \"{x mod 23 = 0, (x + 13) mod 41 = 0, (x + 23) mod 647 = 0, (x + 41) mod 13 = 0, (x + 42) mod 19 = 0, (x + 52) mod 29 = 0, (x + 54) mod 557 = 0, (x + 60) mod 37 = 0, (x + 71) mod 17 = 0}\"                                                                                                                                      \r\n[3] \"{x - 23 floor(x/23) = 0, -41 floor((x + 13)/41) + x + 13 = 0, -647 floor((x + 23)/647) + x + 23 = 0, -13 floor((x + 2)/13) + x + 2 = 0, -19 floor((x + 4)/19) + x + 4 = 0, -29 floor((x + 23)/29) + x + 23 = 0, -557 floor((x + 54)/557) + x + 54 = 0, -37 floor((x + 23)/37) + x + 23 = 0, -17 floor((x + 3)/17) + x + 3 = 0}\"\r\n[4] \"x = 1531146567793219 n + 867295486378319, n element Z\"                                                                                                                                                                                                                                                                         \r\n\r\nVisually inspecting the plaintext shows that the answer to the equation is x = 1531146567793219 n + 867295486378319, n element Z - and the lowest/first possible answer is where n = 0, so that would just leave the intercept of 867295486378319.\r\nThis indeed was the final answer! FWIW, I also left the while loop running while I worked on the other approaches - and it did not succeed.\r\n\r\nDay 14\r\nhttps://adventofcode.com/2020/day/14\r\nDay fourteen - Docking Data!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(binaryLogic)\r\n\r\n  options(scipen  =  9999999)\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nThe initialization program (your puzzle input) can either update the bitmask or write a value to memory. Values and memory addresses are both 36-bit unsigned integers. For example, ignoring bitmasks for a moment, a line like mem[8] = 11 would write the value 11 to memory address 8.\r\n\r\n— Data —\r\n\r\n\r\ninput_14 <- read_lines(here(\"2020\",\"day-14.txt\"))\r\n\r\ninput_14_e1 <- read_lines(here(\"2020\",\"day-14-example1.txt\"))\r\n\r\n\r\n\r\n— Problem 1 —\r\nSo I think I’ll try super-assigning into a global “current_mask” and “current_memory” list, and create functions to update the mask and to write into the memory list.\r\n\r\n\r\ncurrent_mask <- list()\r\ncurrent_memory <- numeric()\r\n\r\nchoose_function <- function(instruction){\r\n  \r\n  if(str_detect(instruction,\"mask\")) update_mask(instruction)\r\n  \r\n  if(str_detect(instruction,\"mem\")) write_memory(instruction)\r\n}\r\n\r\nupdate_mask <- function(instruction){\r\n  \r\n  mask <- str_remove(instruction, \"mask = \") %>% str_split(\"\") %>% unlist()\r\n  \r\n  mask_locations <- str_which(mask,\"X\",negate = TRUE)\r\n\r\n  current_mask <<- list(\r\n    location = mask_locations,\r\n    value = mask[mask_locations] %>% as.integer()\r\n  )\r\n  \r\n  return(current_mask)\r\n}\r\n\r\nupdate_mask(input_14_e1[1])\r\n\r\n\r\n\r\n\r\n$location\r\n[1] 30 35\r\n\r\n$value\r\n[1] 1 0\r\n\r\n\r\n\r\nwrite_memory <- function(instruction){\r\n  \r\n  mem_instruction <- str_split(instruction,\" = \") %>% unlist()\r\n  \r\n  mem_location <- parse_number(mem_instruction[[1]])\r\n  \r\n  mem_value <- parse_integer(mem_instruction[[2]]) %>% \r\n    as.binary(signed = TRUE, size = 5)\r\n  \r\n  mem_value[current_mask$location+4] <- current_mask$value\r\n  \r\n  mem_value <- as.numeric(mem_value)\r\n  \r\n  current_memory[[mem_location]]<<-mem_value\r\n  \r\n  return(mem_value)\r\n}\r\nwrite_memory(input_14_e1[2])\r\n\r\n\r\n\r\n\r\n[1] 73\r\n\r\n\r\n\r\nwalk(input_14,choose_function)\r\n\r\nsum(current_memory %>% unlist(),na.rm = TRUE)\r\n\r\n\r\n\r\n\r\n[1] 10035335144140\r\n\r\n— Problem 2 —\r\n\r\n\r\ninput_14_e2 <- read_lines(here(\"2020\",\"day-14-example2.txt\"))\r\n\r\n\r\n\r\n\r\nInstead, it acts as a memory address decoder. Immediately before a value is written to memory, each bit in the bitmask modifies the corresponding bit of the destination memory address in the following way:\r\nIf the bitmask bit is 0, the corresponding memory address bit is unchanged.\r\nIf the bitmask bit is 1, the corresponding memory address bit is overwritten with 1.\r\nIf the bitmask bit is X, the corresponding memory address bit is floating.\r\n\r\nThis suggests a revised “mask decoder” function:\r\n\r\n\r\ninstruction <- input_14_e2[1]\r\n\r\nupdate_decoder <- function(instruction){\r\n  \r\n  mask <- str_remove(instruction, \"mask = \") %>% str_split(\"\") %>% unlist()\r\n  \r\n  overwrite_locations <- str_which(mask,\"1\")\r\n\r\n  float_locations <- str_which(mask,\"X\")\r\n  \r\n  current_mask <<- list(\r\n    overwrite = overwrite_locations,\r\n    float = float_locations)\r\n  \r\n  return(current_mask)\r\n}\r\n\r\nupdate_decoder(instruction)\r\n\r\n\r\n\r\n\r\n$overwrite\r\n[1] 32 35\r\n\r\n$float\r\n[1] 31 36\r\n\r\n\r\nA floating bit is not connected to anything and instead fluctuates unpredictably. In practice, this means the floating bits will take on all possible values, potentially causing many memory addresses to be written all at once!\r\n\r\nSo instead of masking what the value is, the address being written to is “masked” by floats. I’ll try to use expand_grid to get all the combination of float values.\r\n\r\n\r\ninstruction <- input_14_e2[2]\r\ncurrent_memory <- tibble()\r\n\r\nwrite_memory_two <- function(instruction){\r\n  \r\n  mem_instruction <- str_split(instruction,\" = \") %>% unlist()\r\n  \r\n  mem_location <- parse_number(mem_instruction[[1]]) %>% \r\n    as.binary(signed = TRUE, size = 5)\r\n  \r\n  mem_location[current_mask$overwrite+4] <- 1\r\n    \r\n  x <- tibble(float_locations = current_mask$float + 4,\r\n              float_values = list(c(0,1))) %>% \r\n    deframe() %>% \r\n    expand.grid() \r\n    \r\n  mem_locations <- pmap(x,~ {mem_location[current_mask$float +4] <- c(...); as.numeric(mem_location)}) %>% unlist()\r\n    \r\n  mem_value <- parse_integer(mem_instruction[[2]])\r\n    \r\n  current_memory <<- bind_rows(current_memory,\r\n                               tibble(mem_locations = mem_locations,\r\n                                      mem_value = mem_value))\r\n  return(current_memory)\r\n}\r\n\r\nwrite_memory_two(instruction)\r\n\r\n\r\n\r\n\r\n# A tibble: 8 x 2\r\n  mem_locations mem_value\r\n          <dbl>     <int>\r\n1            26       100\r\n2            58       100\r\n3            27       100\r\n4            59       100\r\n5            26       100\r\n6            58       100\r\n7            27       100\r\n8            59       100\r\n\r\n\r\n\r\ncurrent_memory <- tibble()\r\ncurrent_mask <- list()\r\n\r\nchoose_operation <- function(instruction){\r\n  \r\n  if(str_detect(instruction,\"mask\")) update_decoder(instruction)\r\n  \r\n  if(str_detect(instruction,\"mem\")) write_memory_two(instruction)\r\n}\r\n\r\nwalk(input_14,choose_operation)\r\n\r\ncurrent_memory %>% \r\n  group_by(mem_locations) %>% \r\n  slice_tail() %>% \r\n  ungroup() %>% \r\n  pull(mem_value) %>% \r\n  sum()\r\n\r\n\r\n\r\n\r\n[1] 3817372618036\r\n\r\nRan into some memory overflow issues, so decided to just save all the instructions and slice tail later. (In hindsight, that’s probably more R-like anyway)\r\n\r\nDay 15\r\nhttps://adventofcode.com/2020/day/15\r\nDay fifteen - Rambunctious Recitation!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(slider)\r\n\r\n  options(scipen  =  9999999)\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nSo, after the starting numbers, each turn results in that player speaking aloud either 0 (if the last number is new) or an age (if the last number is a repeat).\r\n\r\n— Data —\r\n\r\n\r\ninput_15 <- c(15,12,0,14,3,1)\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\np1 <- tibble(index = 1:6,value = input_15) %>% \r\n  bind_rows(list(index = 7:2020))\r\n\r\nfind_next <- function(i){\r\n  prev <- p1$value[i - 1]\r\n  new <- 0\r\n  \r\n  if(prev %in% p1$value[-(i-1)]) {\r\n    new <- p1 %>% \r\n      filter(prev == value) %>% \r\n      slice_tail(n = 2) %>% \r\n      pull(index) %>% \r\n      diff()\r\n    }\r\n  \r\n  p1$value[i] <<- new\r\n}\r\n\r\nwalk(7:2020,find_next)\r\ntail(p1$value,1)\r\n\r\n\r\n\r\n\r\n[1] 249\r\n\r\n— Problem 2 —\r\n30,000,000 iterations slows this down heck of a lot!\r\nListing changes I made to first solution:\r\ninstead of storing what each iteration said, store when each number was last said\r\nreconfigure to store a vector of previous value and a second vector of value before previous value\r\npre-emptively build out the previous vectors to 100,000 long - if overflow, increase incrementally - this avoids copy on modify\r\npass solutions from prev_1 to prev_2 by location\r\ndon’t recalculate indexes twice for each loop - pre-set it before the loop and then do it at the end of loop\r\nsuperassigning is slow, move the superassigned thing inside the function\r\ntibbles are slow. matrices are slow. data.table is slow in this context too.\r\n\r\n\r\nfind_next2 <- function(p1, range) {\r\n  \r\n  p2 <- p1 %>% \r\n    group_by(value) %>% \r\n    slice_tail(n=2) %>%\r\n    mutate(rank = rank(desc(index))) %>% \r\n    ungroup() %>% \r\n    pivot_wider(names_from = rank, names_prefix = \"prev_\",values_from = index) %>% \r\n    arrange(value) %>% \r\n    left_join(\r\n      y = .,\r\n      x = tibble(value = 0:100000),\r\n      by = 'value'\r\n    )\r\n  \r\n  value <- p2$value %>% as.integer()\r\n  \r\n  prev_1 <- p2$prev_1\r\n  \r\n  prev_2 <- p2$prev_2\r\n  \r\n  index <- which(prev_1 == max(prev_1,na.rm=TRUE))\r\n  \r\n  for (i in range) {\r\n    \r\n    prev_value <- prev_2[index]\r\n    index <- 1\r\n    \r\n    if(!is.na(prev_value)) index <- i - prev_value\r\n    \r\n    prev_2[index] <- prev_1[index]\r\n    prev_1[index] <- i\r\n    \r\n    # if(i %% 1000000 ==0) message(i)\r\n  }\r\n  \r\n  # Return the last value\r\n  return(index - 1)\r\n}\r\ntictoc::tic()\r\nfind_next2(p1,2021:30000000)\r\ntictoc::toc()\r\n\r\n\r\n\r\n\r\n[1] 41687\r\n\r\n\r\nDay 16\r\nhttps://adventofcode.com/2020/day/16\r\nDay sixteen - Ticket Translation!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n\r\n  options(scipen  =  9999999)\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nUnfortunately, you can’t actually read the words on the ticket. You can, however, read the numbers, and so you figure out the fields these tickets must have and the valid ranges for values in those fields.\r\nYou collect the rules for ticket fields, the numbers on your ticket, and the numbers on other nearby tickets for the same train service (via the airport security cameras) together into a single document you can reference (your puzzle input).\r\n\r\n— Data —\r\n\r\n\r\ninput_16 <- read_lines(here(\"2020\",\"day-16.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\nDefinitely a problem that would benefit from tidying. Also going to go ahead and create an integer vector for each rule range, which will facilitate %in% checks later.\r\n\r\n\r\nx <- tibble(input = input_16) %>% \r\n  mutate(group = cumsum(input == \"\"))\r\n\r\nrules <- x %>% \r\n  filter(group == 0) %>% \r\n  separate(input,c(\"rule\",\"values\"),sep = \": \") %>% \r\n  separate_rows(values, sep = \" or \") %>% \r\n  separate(values,c(\"start_value\",\"end_value\"),sep = \"-\",convert = TRUE) %>% \r\n  mutate(range = map2(start_value,end_value,~.x:.y)) %>% \r\n  select(-group) %>% \r\n  group_by(rule) %>% \r\n  summarise(range = list(range))\r\n\r\nyour_ticket <- x %>% \r\n  filter(group == 1, input!=\"\",input!=\"your ticket:\") %>% \r\n  separate_rows(input, sep = \",\", convert = TRUE) %>% \r\n  mutate(field_id = row_number()) %>% \r\n  select(-group)\r\n\r\nother_tickets <- x %>% \r\n  filter(group == 2,input!=\"\",input!=\"nearby tickets:\") %>% \r\n  mutate(ticket_id = row_number()) %>% \r\n  separate_rows(input,sep = \",\",convert = TRUE) %>% \r\n  select(-group)\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\nStart by determining which tickets are completely invalid; these are tickets that contain values which aren’t valid for any field. Ignore your ticket for now.\r\nConsider the validity of the nearby tickets you scanned. What is your ticket scanning error rate?\r\n\r\n\r\n\r\nrule_range <- rules$range %>% unlist() %>% unique()\r\n\r\ncheck_invalid <- other_tickets %>% \r\n  mutate(check = input %in% rule_range) %>% \r\n  filter(!check)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhead(check_invalid)\r\n\r\n\r\n# A tibble: 6 x 3\r\n  input ticket_id check\r\n  <int>     <int> <lgl>\r\n1     8         2 FALSE\r\n2     4        13 FALSE\r\n3     3        23 FALSE\r\n4    24        25 FALSE\r\n5   979        29 FALSE\r\n6   984        34 FALSE\r\n\r\nsum(check_invalid$input)\r\n\r\n\r\n[1] 25895\r\n\r\n— Problem 2 —\r\n\r\nUsing the valid ranges for each field, determine what order the fields appear on the tickets. The order is consistent between all tickets: if seat is the third field, it is the third field on every ticket, including your ticket.\r\n\r\nLooks straightforward enough: filter out the ticket ids that are invalid, then create a field_id and summarise the values for each field_id as a vector.\r\n\r\n\r\nvalid_other <- other_tickets %>%\r\n  filter(!ticket_id %in% check_invalid$ticket_id) %>% \r\n  group_by(ticket_id) %>% \r\n  mutate(field_id = row_number()) %>% \r\n  ungroup()\r\n\r\nfield_summary <- valid_other %>%\r\n  arrange(input) %>% \r\n  group_by(field_id) %>% \r\n  summarise(values = list(input),\r\n            min = min(input,na.rm = TRUE),\r\n            max = max(input,na.rm = TRUE))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhead(field_summary)\r\n\r\n\r\n# A tibble: 6 x 4\r\n  field_id values        min   max\r\n     <int> <list>      <int> <int>\r\n1        1 <int [190]>    50   916\r\n2        2 <int [190]>    55   946\r\n3        3 <int [190]>    50   947\r\n4        4 <int [190]>    60   945\r\n5        5 <int [190]>    51   948\r\n6        6 <int [190]>    52   947\r\n\r\nWe can check all fields against all rules with crossing, which’ll create one row for every rule x field - from there, run an %in% operator to check whether all values are in a range, and then filter to where these checks are TRUE. Then summarise this by the rule so that we can see what field_options there are for each rule\r\n\r\n\r\ncheck_fields <- crossing(rules,field_summary) %>% \r\n  mutate(range = map(range,unlist)) %>% \r\n  mutate(check = map2_lgl(range,values,~all(.y %in% .x))) %>% \r\n  filter(check)\r\n\r\nfield_options <- check_fields %>% \r\n  group_by(rule) %>% \r\n  summarise(n = n(),field_id = list(field_id)) %>% \r\n  ungroup() %>% \r\n  arrange(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfield_options\r\n\r\n\r\n# A tibble: 20 x 3\r\n   rule                   n field_id  \r\n   <chr>              <int> <list>    \r\n 1 arrival location       1 <int [1]> \r\n 2 train                  2 <int [2]> \r\n 3 arrival station        3 <int [3]> \r\n 4 price                  4 <int [4]> \r\n 5 arrival track          5 <int [5]> \r\n 6 wagon                  6 <int [6]> \r\n 7 route                  7 <int [7]> \r\n 8 departure time         8 <int [8]> \r\n 9 departure station      9 <int [9]> \r\n10 departure platform    10 <int [10]>\r\n11 departure date        11 <int [11]>\r\n12 departure location    12 <int [12]>\r\n13 departure track       13 <int [13]>\r\n14 duration              14 <int [14]>\r\n15 type                  15 <int [15]>\r\n16 arrival platform      16 <int [16]>\r\n17 zone                  17 <int [17]>\r\n18 seat                  18 <int [18]>\r\n19 class                 19 <int [19]>\r\n20 row                   20 <int [20]>\r\n\r\nInspecting these options, we can see that there’s only one option for arrival location, two options for train (one of which is the only option for arrival location), three options for arrival station (but two are in the previous etc) - and continuing the visual inspection shows this pattern carries forward for all twenty fields.\r\nWriting a quick little loop here to assign the fields starting with the first one.\r\n\r\n\r\nunassigned <- field_options\r\n\r\nassigned <- tibble(rule = NULL, field_id = NULL)\r\n\r\nwhile(nrow(unassigned)>0){\r\n  \r\n  assigned <- unassigned %>% \r\n    slice(1) %>% \r\n    bind_rows(assigned,.)\r\n  \r\n  unassigned <- unassigned %>% \r\n    tail(n = -1) %>% \r\n    mutate(field_id = map(field_id, ~.x[!.x %in% assigned$field_id]))\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\nyour_assignment <- assigned %>% \r\n  mutate(field_id = map_dbl(field_id,unlist)) %>% \r\n  left_join(your_ticket, by = c(\"field_id\")) %>% \r\n  filter(str_starts(rule,\"departure\"))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nyour_assignment\r\n\r\n\r\n# A tibble: 6 x 4\r\n  rule                   n field_id input\r\n  <chr>              <int>    <dbl> <int>\r\n1 departure time         8       19   193\r\n2 departure station      9        1    61\r\n3 departure platform    10       13   197\r\n4 departure date        11       20   157\r\n5 departure location    12       15   181\r\n6 departure track       13        7    89\r\n\r\nprod(your_assignment$input)\r\n\r\n\r\n[1] 5865723727753\r\n\r\n\r\nDay 17\r\nhttps://adventofcode.com/2020/day/17\r\nDay seventeen - Conway Cubes!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(furrr)\r\n  plan(multisession)\r\n\r\n  options(scipen = 9999999)\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n\r\n\r\n— Description —\r\n\r\nThe experimental energy source is based on cutting-edge technology: a set of Conway Cubes contained in a pocket dimension! When you hear it’s having problems, you can’t help but agree to take a look.\r\nThe pocket dimension contains an infinite 3-dimensional grid. At every integer 3-dimensional coordinate (x,y,z), there exists a single cube which is either active or inactive.\r\n\r\nSo essentially Conway’s game of life again…but in three dimensions?\r\n— Data —\r\n\r\n\r\ninput_17 <- read_lines(here(\"2020\", \"day-17.txt\"))\r\ninput_17_e <- read_lines(here(\"2020\", \"day-17-example1.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\nExploring a new part of R to me: arrays, which are vertically stacked matrices.\r\n\r\n\r\nexample_matrix <- tibble(x = input_17_e) %>%\r\n  mutate(x = str_split(x, \"\")) %>%\r\n  unnest_wider(x, names_sep = \"_\") %>%\r\n  mutate_all(~ case_when(.x == \"#\" ~ 1, TRUE ~ 0)) %>%\r\n  as.matrix()\r\n\r\nexample_empty <- matrix(\r\n  data = rep(0, length(example_matrix)),\r\n  nrow = nrow(example_matrix),\r\n  ncol = ncol(example_matrix)\r\n)\r\n\r\nexample_array <- c(example_empty, example_matrix, example_empty) %>%\r\n  array(dim = c(nrow(example_matrix), ncol(example_matrix), 3))\r\n\r\ninput_matrix <- tibble(x = input_17) %>%\r\n  mutate(x = str_split(x, \"\")) %>%\r\n  unnest_wider(x, names_sep = \"_\") %>%\r\n  mutate_all(~ case_when(.x == \"#\" ~ 1, TRUE ~ 0)) %>%\r\n  as.matrix()\r\n\r\ninput_empty <- matrix(\r\n  data = rep(0, length(input_matrix)), byrow = TRUE,\r\n  nrow = nrow(input_matrix),\r\n  ncol = ncol(input_matrix)\r\n)\r\n\r\ninput_array <- c(input_empty, input_matrix, input_empty) %>%\r\n  array(dim = c(nrow(input_matrix), ncol(input_matrix), 3))\r\n\r\n\r\n\r\n\r\n\r\n\r\nOkay! So now we have the starting states of the example as example_array and the actual problem as input_array. We can access the dimensions of the arrays via\r\n\r\n\r\ndim(example_array)\r\n\r\n\r\n[1] 3 3 3\r\n\r\nand access a specific layer with array[row,column,layer].\r\n\r\n\r\nexample_array[1, 2, 2]\r\n\r\n\r\n[1] 1\r\n\r\n— Problem 1 —\r\nWe can build out a list of indices with the dimensions, I think!\r\n\r\n\r\n# array <- example_array\r\n\r\nget_indices <- function(array) {\r\n  dimensions <- dim(array)\r\n\r\n  actual_indices <- crossing(\r\n    x = seq_len(dimensions[[1]]),\r\n    y = seq_len(dimensions[[2]]),\r\n    z = seq_len(dimensions[[3]])\r\n  ) %>%\r\n    arrange(z, x, y) %>%\r\n    mutate(\r\n      value = pmap_dbl(list(x, y, z), ~ array[...]),\r\n      x = x + 1,\r\n      y = y + 1\r\n    )\r\n\r\n  indices <- crossing(\r\n    x = seq_len(dimensions[[1]] + 2),\r\n    y = seq_len(dimensions[[2]] + 2),\r\n    z = seq_len(dimensions[[3]])\r\n  ) %>%\r\n    arrange(z, x, y) %>%\r\n    left_join(actual_indices, by = c(\"x\", \"y\", \"z\")) %>%\r\n    mutate_all(replace_na, 0)\r\n\r\n  return(indices)\r\n}\r\n\r\nexample_indices <- get_indices(example_array)\r\n\r\n\r\n\r\nNow to create a function to check the neighbouring indices and count nearby occupied cells.\r\n\r\n\r\n# indices <- example_indices\r\n# x <- 1\r\n# y <- 2\r\n# z <- 2\r\n\r\ncount_neighbours <- function(x, y, z, indices) {\r\n  x_max <- max(indices$x)\r\n  y_max <- max(indices$y)\r\n  z_max <- max(indices$z)\r\n\r\n  increments <- c(-1, 0, 1)\r\n\r\n  neighbours <- crossing(\r\n    x = increments + x,\r\n    y = increments + y,\r\n    z = increments + z\r\n  ) %>%\r\n    filter(\r\n      !(.data$x == .env$x & .data$y == .env$y & .data$z == .env$z),\r\n      between(.data$x, 1, x_max),\r\n      between(.data$y, 1, y_max),\r\n      between(.data$z, 1, z_max)\r\n    ) %>%\r\n    mutate(value = pmap_dbl(list(x, y, z), ~ indices$value[indices$x == ..1 & indices$y == ..2 & indices$z == ..3])) %>%\r\n    pull(value) %>%\r\n    sum()\r\n\r\n  return(neighbours)\r\n}\r\n\r\nexample_neighbours <- example_indices %>%\r\n  mutate(neighbours = pmap_dbl(list(x, y, z), count_neighbours, .))\r\n\r\n\r\n\r\nNow that we have the neighbours, we need to increment their values based on the rules.\r\n\r\n\r\n# indices <- example_neighbours\r\n\r\napply_rules <- function(indices) {\r\n  x <- indices %>%\r\n    mutate(new_value = case_when(\r\n      value == 1 & neighbours %in% c(2, 3) ~ 1,\r\n      value == 1 ~ 0,\r\n      value == 0 & neighbours == 3 ~ 1,\r\n      TRUE ~ 0\r\n    ))\r\n  return(x)\r\n}\r\n\r\nexample_count <- example_neighbours %>%\r\n  apply_rules()\r\n\r\n\r\n\r\n(I was stumped for a while here as to why my puzzle input did not match up to the example, but consulting no-spoilers-reddit seems that they’re dropping empty x/y dimensions which is quite annoying!)\r\nNow to increment the array in every direction (but sticking with a list of indices for now, I find that easier to work with mentally)\r\n\r\n\r\n# indices <- example_count\r\ngrow_indices <- function(indices) {\r\n  new_x <- max(indices$x + 2) %>% seq_len()\r\n  new_y <- max(indices$y + 2) %>% seq_len()\r\n  new_z <- max(indices$z + 2) %>% seq_len()\r\n\r\n  new_indices <- indices %>%\r\n    transmute(\r\n      x = x + 1,\r\n      y = y + 1,\r\n      z = z + 1,\r\n      value = new_value\r\n    )\r\n\r\n  indices <- crossing(\r\n    x = new_x,\r\n    y = new_y,\r\n    z = new_z\r\n  ) %>%\r\n    left_join(new_indices, by = c(\"x\", \"y\", \"z\")) %>%\r\n    mutate(value = replace_na(value, 0))\r\n\r\n  return(indices)\r\n}\r\n# grow_indices(example_count)\r\n\r\n\r\n\r\nWrap it all into a caller function and for-loop.\r\n\r\n\r\n# array <- example_array\r\n# times <- 6\r\n\r\nrun_conwaycube <- function(array, times) {\r\n  indices <- get_indices(array)\r\n\r\n  for (i in seq_len(times)) {\r\n    indices <- indices %>%\r\n      mutate(neighbours = pmap_dbl(list(x, y, z), count_neighbours, .)) %>%\r\n      apply_rules() %>%\r\n      grow_indices()\r\n\r\n    message(paste(i, Sys.time()))\r\n  }\r\n\r\n  return(sum(indices$value))\r\n}\r\n\r\nrun_conwaycube(input_array,6)\r\n\r\n\r\n\r\n1 2020-12-17 10:26:13\r\n2 2020-12-17 10:26:16\r\n3 2020-12-17 10:26:22\r\n4 2020-12-17 10:26:33\r\n5 2020-12-17 10:26:52\r\n6 2020-12-17 10:27:23\r\n\r\n280\r\n— Problem 2 —\r\nFOUR DIMENSIONS?! (brain explodes)\r\nActually, maybe I can just adjust my functions for a fourth dimension w\r\n\r\n\r\nget_indices_4d <- function(array) {\r\n  \r\n  dimensions <- dim(array)\r\n  \r\n  actual_indices <- crossing(\r\n    x = seq_len(dimensions[[1]]),\r\n    y = seq_len(dimensions[[2]]),\r\n    z = seq_len(dimensions[[3]])\r\n  ) %>%\r\n    arrange(z, x, y) %>%\r\n    mutate(\r\n      value = pmap_dbl(list(x, y, z), ~ array[...]),\r\n      x = x + 1,\r\n      y = y + 1,\r\n      w = 2\r\n    )\r\n  \r\n  indices <- crossing(\r\n    x = seq_len(dimensions[[1]] + 2),\r\n    y = seq_len(dimensions[[2]] + 2),\r\n    z = seq_len(dimensions[[3]]),\r\n    w = seq_len(dimensions[[3]])\r\n  ) %>%\r\n    arrange(z, x, y, w) %>%\r\n    left_join(actual_indices, by = c(\"x\", \"y\", \"z\", \"w\")) %>%\r\n    mutate_all(replace_na, 0)\r\n  \r\n  return(indices)\r\n}\r\n\r\ncount_neighbours_4d <- function(x, y, z, w, indices) {\r\n  x_max <- max(indices$x)\r\n  y_max <- max(indices$y)\r\n  z_max <- max(indices$z)\r\n  w_max <- max(indices$w)\r\n  \r\n  increments <- c(-1, 0, 1)\r\n  \r\n  neighbours <- crossing(\r\n    x = increments + x,\r\n    y = increments + y,\r\n    z = increments + z,\r\n    w = increments + w\r\n  ) %>%\r\n    filter(\r\n      !(.data$x == .env$x & \r\n          .data$y == .env$y & \r\n          .data$z == .env$z & \r\n          .data$w == .env$w),\r\n      between(.data$x, 1, x_max),\r\n      between(.data$y, 1, y_max),\r\n      between(.data$z, 1, z_max),\r\n      between(.data$w, 1, w_max)\r\n    ) %>%\r\n    mutate(\r\n      value = pmap_dbl(\r\n        list(x, y, z, w), \r\n        ~ indices$value[indices$x == ..1 & \r\n                          indices$y == ..2 & \r\n                          indices$z == ..3 & \r\n                          indices$w == ..4])) %>%\r\n    pull(value) %>%\r\n    sum()\r\n  \r\n  return(neighbours)\r\n}\r\n\r\n# apply rules doesn't change since rules are the same\r\n\r\ngrow_indices_4d <- function(indices) {\r\n  new_x <- max(indices$x + 2) %>% seq_len()\r\n  new_y <- max(indices$y + 2) %>% seq_len()\r\n  new_z <- max(indices$z + 2) %>% seq_len()\r\n  new_w <- max(indices$w + 2) %>% seq_len()\r\n  \r\n  new_indices <- indices %>%\r\n    transmute(\r\n      x = x + 1,\r\n      y = y + 1,\r\n      z = z + 1,\r\n      w = w + 1,\r\n      value = new_value\r\n    )\r\n  \r\n  indices <- crossing(\r\n    x = new_x,\r\n    y = new_y,\r\n    z = new_z,\r\n    w = new_w\r\n  ) %>%\r\n    left_join(new_indices, by = c(\"x\", \"y\", \"z\", \"w\")) %>%\r\n    mutate(value = replace_na(value, 0))\r\n  \r\n  return(indices)\r\n}\r\n\r\nrun_conwaycube_4d <- function(array, times) {\r\n  \r\n  indices <- get_indices_4d(array)\r\n  \r\n  message(paste(Sys.time(), nrow(indices)))\r\n  \r\n  for (i in seq_len(times)) {\r\n    indices <- indices %>%\r\n      mutate(neighbours = pmap_dbl(list(x, y, z, w), count_neighbours_4d, .)) %>%\r\n      apply_rules() %>%\r\n      grow_indices_4d()\r\n    message(paste(i, Sys.time(), nrow(indices)))\r\n  }\r\n  return(sum(indices$value))\r\n}\r\n\r\nrun_conwaycube_4d(input_array, 6)\r\n\r\n\r\n\r\n2020-12-17 02:01:36 900\r\n1 2020-12-17 02:01:41 3600\r\n2 2020-12-17 02:02:12 9604\r\n3 2020-12-17 02:04:46 20736\r\n4 2020-12-17 02:15:10 39204\r\n5 2020-12-17 02:50:04 67600\r\n6 2020-12-17 04:35:08 108900\r\n\r\n[1] 1696\r\nAdmittedly, I plugged this in and went to sleep - but it was the correct answer!\r\n— Iterating on Problem 2 for speed —\r\nProblem 2 takes quite some time to run. Trying a few approaches to trimming it down:\r\nFirstly, as Liam Y suggested in the R4DS Slack - arrange the neighbour function so that it’s only checking neighbours that have positive integer values:\r\n\r\n\r\ncount_neighbours_4d <- function(indices){\r\n\r\n  filtered_indices <- indices %>%\r\n    filter(value == 1) # This should reduce the amount of iteration needed!\r\n\r\n  indices %>%\r\n    mutate(neighbours = pmap_dbl(list(x,y,z,w),check_each_neighbour,filtered_indices))\r\n}\r\n\r\ncheck_each_neighbour <- function(x, y, z, w, indices){\r\n\r\n  increments <- c(-1, 0, 1)\r\n\r\n  n <- crossing(\r\n    x = increments + x,\r\n    y = increments + y,\r\n    z = increments + z,\r\n    w = increments + w\r\n  ) %>%\r\n    filter(\r\n      !(.data$x == .env$x & \r\n          .data$y == .env$y & \r\n          .data$z == .env$z & \r\n          .data$w == .env$w)\r\n    ) %>%\r\n    mutate(\r\n      value = pmap(list(.data$x,.data$y,.data$z,.data$w),\r\n                   ~(indices$value[indices$x == ..1 & indices$y == ..2 & indices$z == ..3 & indices$w == ..4]))) %>%\r\n    pull(value) %>%\r\n    unlist() %>%\r\n    sum(na.rm = TRUE)\r\n\r\n  return(n)\r\n}\r\n\r\nrun_conwaycube_4d <- function(array, times) {\r\n  indices <- get_indices_4d(array)\r\n\r\n  message(paste(Sys.time(), nrow(indices)))\r\n\r\n  for (i in seq_len(times)) {\r\n    indices <- indices %>%\r\n      count_neighbours_4d() %>% \r\n      apply_rules() %>%\r\n      grow_indices_4d()\r\n\r\n    message(paste(i, Sys.time(), nrow(indices)))\r\n  }\r\n\r\n  return(sum(indices$value))\r\n}\r\n\r\nrun_conwaycube_4d(input_array, 6)\r\n\r\n\r\n\r\n2020-12-17 16:08:14 900\r\n1 2020-12-17 16:08:18 3600\r\n2 2020-12-17 16:08:38 9604\r\n3 2020-12-17 16:09:29 20736\r\n4 2020-12-17 16:11:39 39204\r\n5 2020-12-17 16:15:26 67600\r\n6 2020-12-17 16:25:28 108900\r\n\r\n[1] 1696\r\nJust doing that much shrunk the run-time from 2 hours 35 minutes to ~17 minutes! I can do better though, I think - in Day 11’s final approach, I arranged things into a matrix and approached it from there - I think I can definitely do the same here! (and also, add parallel processing because duh)\r\n\r\n\r\ncount_neighbours_4d <- function(indices){\r\n\r\n  v <- indices %>% \r\n    arrange(w,z,y,x) %>% \r\n    pull(value)\r\n  \r\n  a <- array(v,dim = c(max(indices$x),\r\n                       max(indices$y),\r\n                       max(indices$z),\r\n                       max(indices$w)))\r\n\r\n  i <- indices %>%\r\n    mutate(neighbours = future_pmap_dbl(.l = list(.data$x,.data$y,.data$z,.data$w),.f = check_each_neighbour,a = .env$a))\r\n\r\n  return(i)\r\n}\r\n\r\ncheck_each_neighbour <- function(x, y, z, w, a){\r\n\r\n  increments <- c(-1, 0, 1)\r\n\r\n  # browser()\r\n  \r\n  n <- crossing(\r\n    x = increments + x,\r\n    y = increments + y,\r\n    z = increments + z,\r\n    w = increments + w\r\n  ) %>%\r\n    filter(\r\n      !(.data$x == .env$x & \r\n          .data$y == .env$y & \r\n          .data$z == .env$z & \r\n          .data$w == .env$w),\r\n      between(.data$x,1,dim(a)[[1]]),\r\n      between(.data$y,1,dim(a)[[2]]),\r\n      between(.data$z,1,dim(a)[[3]]),\r\n      between(.data$w,1,dim(a)[[4]]),\r\n    ) %>%\r\n    mutate(\r\n      value = pmap_dbl(\r\n        list(.data$x,.data$y,.data$z,.data$w),\r\n        ~a[..1,..2,..3,..4])) %>%\r\n    pull(value) %>%\r\n    unlist() %>%\r\n    sum(na.rm = TRUE)\r\n\r\n  return(n)\r\n}\r\n\r\nrun_conwaycube_4d <- function(array, times) {\r\n  indices <- get_indices_4d(array)\r\n\r\n  message(paste(Sys.time(), nrow(indices)))\r\n\r\n  for (i in seq_len(times)) {\r\n    indices <- indices %>%\r\n      count_neighbours_4d() %>% \r\n      apply_rules() %>%\r\n      grow_indices_4d()\r\n\r\n    message(paste(i, Sys.time(), nrow(indices)))\r\n  }\r\n\r\n  return(sum(indices$value))\r\n}\r\n\r\nrun_conwaycube_4d(input_array, 6)\r\n\r\n\r\n\r\n2020-12-17 18:39:43 900\r\n1 2020-12-17 18:39:45 3600\r\n2 2020-12-17 18:39:48 9604\r\n3 2020-12-17 18:39:56 20736\r\n4 2020-12-17 18:40:13 39204\r\n5 2020-12-17 18:40:44 67600\r\n6 2020-12-17 18:41:39 108900\r\n[1] 1696\r\nShaving it down to two minutes runtime is extremely satisfying!\r\n\r\nDay 18\r\nhttps://adventofcode.com/2020/day/18\r\nDay eighteen - Operation Order!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(lobstr)\r\n  # library(furrr)\r\n  # plan(multisession)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n  options(scipen = 9999999)\r\n\r\n\r\n\r\n— Description —\r\n\r\nUnfortunately, it seems like this “math” follows different rules than you remember.\r\nThe homework (your puzzle input) consists of a series of expressions that consist of addition (+), multiplication (*), and parentheses ((…)). Just like normal math, parentheses indicate that the expression inside must be evaluated before it can be used by the surrounding expression. Addition still finds the sum of the numbers on both sides of the operator, and multiplication still finds the product.\r\nHowever, the rules of operator precedence have changed. Rather than evaluating multiplication before addition, the operators have the same precedence, and are evaluated left-to-right regardless of the order in which they appear.\r\n\r\n— Data —\r\n\r\n\r\ninput_18 <- read_lines(here(\"2020\", \"day-18.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\noperations <- tibble(x = input_18)\r\n\r\n\r\n\r\n— Problem 1 —\r\nR doesn’t have editable math operator precedence (which is a good thing!), but we can trick the R parser into evaluating * at the same level as + by string-replacing * with - and then switching the definition of - to be equal to *.\r\nThe R parser will read the operator list and decide which ones to do, and it knows that “+” is equal in precedence to “-”. So it will evaluate them left to right, and it goes back to the new definition of “-” which is \"*\".\r\n\r\n\r\n`-` <- `*`\r\n  \r\np1 <- operations %>% \r\n  mutate(modified_x = str_replace_all(x,\"\\\\*\",\"\\\\-\"),\r\n         output = map_dbl(modified_x,~ eval(parse(text = .x))))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhead(p1)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  modified_x                                                    output\r\n  <chr>                                                          <dbl>\r\n1 9 - 8 + 2 + (4 - (2 - 2 + 9 - 2) - 9 - 3 - 8) + 8 - 5         1.13e5\r\n2 8 - (9 + 5 + 5 - 6 + 8 - 3) - 5 - 7 - 4 + 9                   4.10e5\r\n3 (9 + (2 - 6 + 7 - 5)) - (7 + 7 - 5 + (6 + 2 + 6) - (7 - 8~    7.98e6\r\n4 ((8 + 3 - 6 - 2) - 9 + 3) + 5 + 6 - 3                         3.61e3\r\n5 6 - (9 + 6 - (7 + 4 + 2 + 5 + 6) - 7 + 3 - (5 - 8 - 6 + 6~    1.67e9\r\n6 (8 - 6 + 8) + 6 - 8 - (9 - (6 + 8 - 3 + 8) + (7 - 9 - 6 -~    9.44e6\r\n\r\n\r\n\r\nsum(p1$output)\r\n\r\n\r\n\r\n\r\n[1] 16332191652452\r\n\r\nFor extra credit, here’s the abstract syntax tree for the first operation as written normally:\r\n\r\n\r\nlobstr::ast(expression(9 * 8 + 2 + (4 * (2 * 2 + 9 * 2) * 9 * 3 * 8) + 8 * 5))\r\n\r\n\r\no-expression \r\n\\-o-`+` \r\n  +-o-`+` \r\n  | +-o-`+` \r\n  | | +-o-`*` \r\n  | | | +-9 \r\n  | | | \\-8 \r\n  | | \\-2 \r\n  | \\-o-`(` \r\n  |   \\-o-`*` \r\n  |     +-o-`*` \r\n  |     | +-o-`*` \r\n  |     | | +-o-`*` \r\n  |     | | | +-4 \r\n  |     | | | \\-o-`(` \r\n  |     | | |   \\-o-`+` \r\n  |     | | |     +-o-`*` \r\n  |     | | |     | +-2 \r\n  |     | | |     | \\-2 \r\n  |     | | |     \\-o-`*` \r\n  |     | | |       +-9 \r\n  |     | | |       \\-2 \r\n  |     | | \\-9 \r\n  |     | \\-3 \r\n  |     \\-8 \r\n  \\-o-`*` \r\n    +-8 \r\n    \\-5 \r\n\r\nand the revised version:\r\n\r\n\r\nlobstr::ast(expression(9 - 8 + 2 + (4 - (2 - 2 + 9 - 2) - 9 - 3 - 8) + 8 - 5))\r\n\r\n\r\no-expression \r\n\\-o-`-` \r\n  +-o-`+` \r\n  | +-o-`+` \r\n  | | +-o-`+` \r\n  | | | +-o-`-` \r\n  | | | | +-9 \r\n  | | | | \\-8 \r\n  | | | \\-2 \r\n  | | \\-o-`(` \r\n  | |   \\-o-`-` \r\n  | |     +-o-`-` \r\n  | |     | +-o-`-` \r\n  | |     | | +-o-`-` \r\n  | |     | | | +-4 \r\n  | |     | | | \\-o-`(` \r\n  | |     | | |   \\-o-`-` \r\n  | |     | | |     +-o-`+` \r\n  | |     | | |     | +-o-`-` \r\n  | |     | | |     | | +-2 \r\n  | |     | | |     | | \\-2 \r\n  | |     | | |     | \\-9 \r\n  | |     | | |     \\-2 \r\n  | |     | | \\-9 \r\n  | |     | \\-3 \r\n  | |     \\-8 \r\n  | \\-8 \r\n  \\-5 \r\n\r\n— Problem 2 —\r\nProblem 2 is in the same vein but now just needs the + evaluated before the *, so we can do the same * to - swap and then now switch + to the * symbol, so that R thinks it is evaluated before the -.\r\n\r\n\r\n`-` <- `*`\r\n`*` <- `+`\r\n  \r\np2 <- operations %>% \r\n  mutate(modified_x = str_replace_all(x,\"\\\\*\",\"\\\\-\"),\r\n         modified_x = str_replace_all(modified_x,\"\\\\+\",\"\\\\*\"),\r\n         output = map_dbl(modified_x,~ eval(parse(text = .x))))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nhead(p2)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  modified_x                                                    output\r\n  <chr>                                                          <dbl>\r\n1 9 - 8 * 2 * (4 - (2 - 2 * 9 - 2) - 9 - 3 - 8) * 8 - 5         1.71e6\r\n2 8 - (9 * 5 * 5 - 6 * 8 - 3) - 5 - 7 - 4 * 9                   2.90e6\r\n3 (9 * (2 - 6 * 7 - 5)) - (7 * 7 - 5 * (6 * 2 * 6) - (7 - 8~    7.04e7\r\n4 ((8 * 3 - 6 - 2) - 9 * 3) * 5 * 6 - 3                         4.78e3\r\n5 6 - (9 * 6 - (7 * 4 * 2 * 5 * 6) - 7 * 3 - (5 - 8 - 6 * 6~    4.64e9\r\n6 (8 - 6 * 8) * 6 - 8 - (9 - (6 * 8 - 3 * 8) * (7 - 9 - 6 -~    4.81e8\r\n\r\n\r\n\r\nsum(p2$output)\r\n\r\n\r\n\r\n\r\n[1] 351175492232654\r\n\r\nThe same “extra credit exercise”:\r\n\r\n\r\nlobstr::ast(expression(9 * 8 + 2 + (4 * (2 * 2 + 9 * 2) * 9 * 3 * 8) + 8 * 5))\r\n\r\n\r\no-expression \r\n\\-o-`+` \r\n  +-o-`+` \r\n  | +-o-`+` \r\n  | | +-o-`*` \r\n  | | | +-9 \r\n  | | | \\-8 \r\n  | | \\-2 \r\n  | \\-o-`(` \r\n  |   \\-o-`*` \r\n  |     +-o-`*` \r\n  |     | +-o-`*` \r\n  |     | | +-o-`*` \r\n  |     | | | +-4 \r\n  |     | | | \\-o-`(` \r\n  |     | | |   \\-o-`+` \r\n  |     | | |     +-o-`*` \r\n  |     | | |     | +-2 \r\n  |     | | |     | \\-2 \r\n  |     | | |     \\-o-`*` \r\n  |     | | |       +-9 \r\n  |     | | |       \\-2 \r\n  |     | | \\-9 \r\n  |     | \\-3 \r\n  |     \\-8 \r\n  \\-o-`*` \r\n    +-8 \r\n    \\-5 \r\n\r\n\r\n\r\nlobstr::ast(9 - 8 * 2 * (4 - (2 - 2 * 9 - 2) - 9 - 3 - 8) * 8 - 5)\r\n\r\n\r\no-`-` \r\n+-o-`-` \r\n| +-9 \r\n| \\-o-`*` \r\n|   +-o-`*` \r\n|   | +-o-`*` \r\n|   | | +-8 \r\n|   | | \\-2 \r\n|   | \\-o-`(` \r\n|   |   \\-o-`-` \r\n|   |     +-o-`-` \r\n|   |     | +-o-`-` \r\n|   |     | | +-o-`-` \r\n|   |     | | | +-4 \r\n|   |     | | | \\-o-`(` \r\n|   |     | | |   \\-o-`-` \r\n|   |     | | |     +-o-`-` \r\n|   |     | | |     | +-2 \r\n|   |     | | |     | \\-o-`*` \r\n|   |     | | |     |   +-2 \r\n|   |     | | |     |   \\-9 \r\n|   |     | | |     \\-2 \r\n|   |     | | \\-9 \r\n|   |     | \\-3 \r\n|   |     \\-8 \r\n|   \\-8 \r\n\\-5 \r\n\r\n\r\nDay 19\r\nhttps://adventofcode.com/2020/day/19\r\nDay nineteen - Monster Messages!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  # library(furrr)\r\n  # plan(multisession)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n  options(scipen = 9999999)\r\n\r\n\r\n\r\n— Description —\r\n\r\nThey think their satellite has collected an image of a sea monster! Unfortunately, the connection to the satellite is having problems, and many of the messages sent back from the satellite have been corrupted.\r\nThey sent you a list of the rules valid messages should obey and a list of received messages they’ve collected so far (your puzzle input).\r\nYour goal is to determine the number of messages that completely match rule 0.\r\n\r\n— Data —\r\n\r\n\r\ninput_19 <- read_lines(here(\"2020\", \"day-19.txt\"))\r\n\r\ninput_19_e <- read_lines(here(\"2020\", \"day-19-e.txt\"))\r\n\r\ninput_19_e2 <- read_lines(here(\"2020\", \"day-19-e2.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\nSeems nice to split the list of rules into its own tibble.\r\n\r\n\r\nmessages_e <- tibble(message = input_19_e) %>% \r\n  mutate(type = cumsum(message == \"\")) %>% \r\n  filter(type == 1,message !=\"\") %>% \r\n  select(-type)\r\n\r\nrules_e <- tibble(rule = input_19_e) %>% \r\n  mutate(type = cumsum(rule == \"\")) %>% \r\n  filter(type == 0) %>% \r\n  select(-type) %>% \r\n  separate(rule,into = c(\"rule_id\",\"rule_desc\"), sep = \": \")\r\n\r\nmessages <- tibble(message = input_19) %>% \r\n  mutate(type = cumsum(message == \"\")) %>% \r\n  filter(type == 1,message !=\"\") %>% \r\n  select(-type)\r\n\r\nrules <- tibble(rule = input_19) %>% \r\n  mutate(type = cumsum(rule == \"\")) %>% \r\n  filter(type == 0) %>% \r\n  select(-type) %>% \r\n  separate(rule,into = c(\"rule_id\",\"rule_desc\"), sep = \": \")\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\nYour goal is to determine the number of messages that completely match rule 0.\r\n\r\nOkay, so writing a function that loops over the rules, taking only complete rules (i.e. rules without numbers) and string-replacing them into their rule_id. Also need to add padding so that the rule id doesn’t match individual digits, and need to add parentheses for rules that have an OR condition.\r\n\r\n\r\nrule_recurse <- function(rules){\r\n  \r\n  rules <- rules %>% \r\n    mutate(rule_desc = if_else(str_detect(rule_desc,\"a|b\"), \r\n                               str_remove_all(rule_desc,'\\\\\"'), \r\n                               rule_desc),\r\n           rule_id = paste0(\" \",rule_id,\" \"),\r\n           rule_desc = paste0(\" \",rule_desc,\" \"),\r\n           rule_desc = if_else(str_detect(rule_desc,\"\\\\|\"),\r\n                               paste0(\" ( \",rule_desc,\" ) \"),\r\n                               rule_desc))\r\n  \r\n  while(any(str_detect(rules$rule_desc,\"[0-9]\"))){\r\n    \r\n    x <- rules %>% \r\n      filter(!str_detect(rule_desc,\"[0-9]\"))\r\n    \r\n    for(i in seq_along(x$rule_id)){\r\n      rules$rule_desc <- str_replace_all(rules$rule_desc, x$rule_id[i], x$rule_desc[i])\r\n    }\r\n  }\r\n  \r\n  rules <- rules %>% \r\n    mutate_all(str_remove_all,\" \") %>% \r\n    mutate(rule_desc = paste0(\"^\",rule_desc,\"$\"))\r\n  \r\n  return(rules)\r\n}\r\n \r\nrules_e1 <- rules_e %>% \r\n  rule_recurse() %>% \r\n  filter(rule_id == 0) %>% \r\n  pull(rule_desc)\r\n\r\nmessages_e1 <- messages_e %>% \r\n  mutate(match = str_detect(message,rules_e1))\r\n\r\np1_rules <- rules %>% \r\n  rule_recurse() %>% \r\n  filter(rule_id == 0) %>% \r\n  pull(rule_desc)\r\n\r\np1_messages <- messages %>% \r\n  mutate(match = str_detect(message,p1_rules))\r\n\r\nsum(p1_messages$match)\r\n\r\n\r\n\r\n\r\n[1] 122\r\n\r\n— Problem 2 —\r\n\r\nReplace 8 and 11 with new rules that create looping - how to fix?\r\n\r\nApproach: “Pray to the regex gods and hope they find you worthy”\r\nDeconstructing the rules changes:\r\n8 is 42 | 42 8 - so it starts as 42, and then when replaced with itself becomes 42 42, 42 42 42 etc - we can represent this as “one or more of” pretty easily: 42 + handles that condition.\r\n11 is trickier: 42 31 | 42 11 31 means plugging 42 31 recursively into the middle of another set of 42 and 31. I spent a reading through regex recursion on this one, went to bed, continued trying regex recursion on it, until I eventually decided to hardcode 42 31 | 42 42 31 31 | 42 42 42 31 31 31 etc for like ten iterations of the loop. (I tried fifty, and got a literal stack overflow error!)\r\n\r\n\r\n\r\nmessages_e2 <- tibble(message = input_19_e2) %>% \r\n  mutate(type = cumsum(message == \"\")) %>% \r\n  filter(type == 1,message !=\"\") %>% \r\n  select(-type)\r\n\r\nrules_e2 <- tibble(rule = input_19_e2) %>% \r\n  mutate(type = cumsum(rule == \"\")) %>% \r\n  filter(type == 0) %>% \r\n  select(-type) %>% \r\n  separate(rule,into = c(\"rule_id\",\"rule_desc\"), sep = \": \")\r\n\r\nrule_updater <- function(rules){\r\n  rules %>% \r\n    mutate(\r\n      rule_desc = case_when(\r\n        rule_id == \"8\" ~ \"42 +\",\r\n        rule_id == \"11\" ~ \r\n          paste(\r\n            map_chr(1:10, ~rep_len(42,.x) %>% paste(collapse = \" \")),\r\n            map_chr(1:10, ~rep_len(31,.x) %>% paste(collapse = \" \")),\r\n            collapse = \" | \"),\r\n        TRUE ~ rule_desc))\r\n}\r\n\r\np2_rules_e <- rules_e2 %>% \r\n  rule_updater() %>% \r\n  rule_recurse() %>% \r\n  filter(rule_id == 0) %>% \r\n  pull(rule_desc)\r\n\r\nmessages_p2_e <- messages_e2 %>%\r\n  mutate(match = str_detect(message,p2_rules_e))\r\n\r\nsum(messages_p2_e$match)\r\n\r\n\r\n\r\n\r\n[1] 12\r\n\r\n\r\n\r\np2_rules <- rules %>% \r\n  rule_updater() %>% \r\n  rule_recurse() %>% \r\n  filter(rule_id == 0) %>% \r\n  pull(rule_desc)\r\n\r\np2_messages <- messages %>% \r\n  mutate(match = str_detect(message, p2_rules))\r\n\r\nsum(p2_messages$match)\r\n\r\n\r\n\r\n\r\n[1] 287\r\n\r\nWorking through the example only sort of helped: I got the example to be 12 but the actual problem ended up failing for hours. It was a good filter for bad solutions though, because when the example was wrong I knew not to bother with the actual problem.\r\n\r\nDay 20\r\nhttps://adventofcode.com/2020/day/20\r\nDay twenty - Jurassic Jigsaw!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Description —\r\n\r\nThe camera array consists of many cameras; rather than produce a single square image, they produce many smaller square image tiles that need to be reassembled back into a single image.\r\nWorse yet, the camera array appears to be malfunctioning: each image tile has been rotated and flipped to a random orientation. Your first task is to reassemble the original image by orienting the tiles so they fit together.\r\n\r\n— Data —\r\n\r\n\r\ninput_20 <- read_lines(here(\"2020\", \"day-20.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\ntiles <- tibble(tile = input_20) %>%\r\n  mutate(id = if_else(str_starts(tile,\"Tile\"),tile,NA_character_),\r\n         id = parse_number(id)) %>%  \r\n  fill(id) %>% \r\n  filter(tile!=\"\",str_detect(tile,\"Tile \",negate = TRUE)) %>%\r\n  mutate(tile = str_split(tile,\"\")) %>% \r\n  group_by(id) %>% \r\n  summarise(tile = list(unlist(tile))) %>% \r\n  mutate(tile = map(tile,~matrix(.x,nrow = 10, ncol = 10, byrow = TRUE)))\r\n\r\n\r\n\r\n— Problem 1 —\r\nFind corner tiles.\r\n\r\n\r\ntile_edges <- tiles %>% \r\n  mutate(tile_edges = map(tile, \r\n                          ~list(\r\n                            top = .x[1,], top_rev = rev(.x[1,]),\r\n                            bottom = .x[10,], bottom_rev = rev(.x[10,]),\r\n                            left = .x[,1], left_rev = rev(.x[,1]),\r\n                            right = .x[,10], right_rev = rev(.x[,10])))) %>% \r\n  unnest_longer(tile_edges,indices_to = \"border_position\") %>% \r\n  transmute(id,border_position,tile_edges = map_chr(tile_edges,paste,collapse = \"\")) \r\n\r\np1 <- tile_edges %>% \r\n  group_by(tile_edges) %>% \r\n  mutate(matches = n()-1) %>% \r\n  ungroup() %>% \r\n  group_by(id) %>% \r\n  summarise(sum_matches = sum(matches)/2) %>% \r\n  filter(sum_matches == 2)\r\n\r\np1\r\n\r\n\r\n\r\n\r\n# A tibble: 4 x 2\r\n     id sum_matches\r\n  <dbl>       <dbl>\r\n1  1109           2\r\n2  1693           2\r\n3  2909           2\r\n4  3371           2\r\n\r\n\r\n\r\nprod(p1$id)\r\n\r\n\r\n\r\n\r\n[1] 18411576553343\r\n\r\n— Problem 2 —\r\nAssemble the picture and find the sea monster.\r\n(Internal swearing as I only found the corners first and didn’t actually do the joining bit, so time to catch up)\r\n\r\n\r\nmatching_edges <- tile_edges %>% \r\n  group_by(tile_edges) %>% \r\n  mutate(matches = n()-1, \r\n         matching_tiles = list(id)) %>% \r\n  ungroup() %>% \r\n  filter(matches!=0) %>% \r\n  mutate(matching_tiles = map2_dbl(matching_tiles,id,~.x[.x!=.y])) %>%\r\n  group_by(id) %>% \r\n  mutate(matches = sum(matches)/2) %>% \r\n  ungroup()\r\n\r\nedges <- matching_edges %>% \r\n  filter(matches <= 3) %>% \r\n  distinct(id,matches,matching_tiles) %>% \r\n  filter(matching_tiles %in% .$id)\r\n\r\ncorners <- matching_edges %>% \r\n  filter(matches == 2)\r\n\r\n\r\n\r\n\r\n\r\nid_matrix <- matrix(numeric(),nrow = 12, ncol = 12)\r\n\r\nperimeter <- c(1109,1181)\r\nperimeter_options <- edges %>% \r\n  filter(!matching_tiles %in% perimeter)\r\n\r\nwhile(nrow(perimeter_options)>0){\r\n \r\n  i <- length(perimeter)+1\r\n  \r\n  perimeter[i] <- perimeter_options %>% \r\n    filter(id == tail(perimeter,1)) %>% \r\n    pull(matching_tiles)\r\n  \r\n  perimeter_options <- perimeter_options %>% \r\n    filter(!matching_tiles %in% perimeter)\r\n}\r\n\r\nid_matrix[1,] <- perimeter[1:12]\r\nid_matrix[,12] <- perimeter[12:23]\r\nid_matrix[12,] <- rev(perimeter[23:34])\r\nid_matrix[,1] <- c(1109,rev(perimeter[34:44]))\r\n\r\nrm(perimeter_options,perimeter)\r\n\r\nid_matrix\r\n\r\n\r\n\r\n\r\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n [1,] 1109 1181 2719 1373 1303 1637 3023 1447 1361  1019  1733  1693\r\n [2,] 1487   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  1609\r\n [3,] 3319   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  2861\r\n [4,] 2423   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  1867\r\n [5,] 2161   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  3229\r\n [6,] 2999   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  3313\r\n [7,] 1069   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  3677\r\n [8,] 2371   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  3833\r\n [9,] 3821   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  3779\r\n[10,] 1523   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  2819\r\n[11,] 3637   NA   NA   NA   NA   NA   NA   NA   NA    NA    NA  2917\r\n[12,] 3371 2543 2749 3301 2141 1061 1597 2459 1759  2633  2207  2909\r\n\r\nYAY WE HAVE THE PERIMETER! (Still a mountain to climb, but hey.)\r\nFilling in the middles by looking at the tile above and the tile to the left.\r\n\r\n\r\nmiddles <- matching_edges %>% \r\n  filter(matches == 4) %>% \r\n  distinct(id,matching_tiles)\r\n\r\nfor(col in 2:11){\r\n  for(row in 2:11){\r\n    \r\n    up <- id_matrix[row-1,col]\r\n    left <- id_matrix[row,col-1]\r\n    \r\n    v <- middles %>% \r\n      filter(matching_tiles %in% c(up,left)) %>% \r\n      group_by(id) %>% \r\n      summarise(n = n()) %>% \r\n      filter(n == 2) %>% \r\n      pull(id)\r\n    \r\n    middles <- middles %>% filter(id!=v)\r\n    \r\n    id_matrix[row,col] <- v \r\n  }\r\n}\r\n\r\nrm(up, left, v)\r\n\r\nid_matrix\r\n\r\n\r\n\r\n\r\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n [1,] 1109 1181 2719 1373 1303 1637 3023 1447 1361  1019  1733  1693\r\n [2,] 1487 2441 3671 3221 1367 1097 3761 1601 1091  3253  1667  1609\r\n [3,] 3319 3257 3863 2593 3089 3181 2273 2699 1429  1697  3691  2861\r\n [4,] 2423 1213 1559 2969 2621 3739 1193 1823 2531  1489  2549  1867\r\n [5,] 2161 3019 3881 2411 1619 2081 2617 2707 3527  3467  1439  3229\r\n [6,] 2999 2843 2083 1789 2131 2521 3137 3673 2377  1123  1847  3313\r\n [7,] 1069 2557 2777 1049 1993 1423 3931 1153 2663  1201  1129  3677\r\n [8,] 2371 1553 3727 1249 1607 1741 2683 2039 1327  3011  1033  3833\r\n [9,] 3821 3491 1783 3877 3413 3659 3517 1879 3583  3191  3533  3779\r\n[10,] 1523 3329 2677 2953 3463 1171 1627 2789 3203  3461  1103  2819\r\n[11,] 3637 1997 2221 2467 2287 2551 2897 1747 3967  1657  3299  2917\r\n[12,] 3371 2543 2749 3301 2141 1061 1597 2459 1759  2633  2207  2909\r\n\r\nOkay! So we now have the location of each tile and now need to orient each tile correctly. Again starting from the top corner tile, now rotating and flipping the tile until it fits into the correct orientation.\r\nSome helpers from Stack Overflow: https://stackoverflow.com/questions/16496210/rotate-a-matrix-in-r-by-90-degrees-clockwise\r\n\r\n\r\nrotate_matrix <- function(x) t(x[nrow(x):1,])\r\n\r\nflip_matrix <- function(x) x[nrow(x):1,]\r\n\r\n\r\n\r\nFirst, fill in leftmost column of the matrix, aligning top of new tile with bottom of previous tile.\r\n\r\n\r\ncorrect_tiles <- tiles %>% \r\n  filter(id == 1109)\r\n\r\nfor(i in 2:12){\r\n  \r\n  i_id <- id_matrix[i,1]\r\n  up_id <- id_matrix[i-1,1]\r\n  \r\n  up_tile <- correct_tiles %>% \r\n    filter(id == up_id) %>% \r\n    pluck(\"tile\", 1)\r\n  \r\n  up_bottom <- up_tile[10,] %>% paste(collapse = \"\")\r\n  \r\n  i_tile <- tiles %>% \r\n    filter(id == i_id) %>% \r\n    pluck(\"tile\", 1)\r\n\r\n  i_list <- tibble(tile = list(\r\n    i_tile,\r\n    i_tile %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix()\r\n  )) %>% \r\n    mutate(match = map_lgl(tile,~.x[1,] %>% paste(collapse = \"\") == up_bottom)) %>% \r\n    filter(match)\r\n  \r\n  if(nrow(i_list)==0) stop()\r\n  \r\n  i_tile <- i_list$tile[[1]]\r\n  \r\n  correct_tiles <- tibble(id = i_id, tile = list(i_tile)) %>% \r\n    bind_rows(correct_tiles,.)\r\n  \r\n}\r\n\r\n\r\n\r\nOkay, now orient the top row by accessing the right hand side:\r\n\r\n\r\nfor(i in 2:12){\r\n  \r\n  i_id <- id_matrix[1,i]\r\n  left_id <- id_matrix[1,i-1]\r\n  \r\n  left_tile <- correct_tiles %>% \r\n    filter(id == left_id) %>% \r\n    pluck(\"tile\", 1)\r\n  \r\n  left_right <- left_tile[,10] %>% paste(collapse = \"\")\r\n  \r\n  i_tile <- tiles %>% \r\n    filter(id == i_id) %>% \r\n    pluck(\"tile\", 1)\r\n  \r\n  i_left <- i_tile[,1] %>% paste(collapse = \"\")\r\n  \r\n  i_list <- tibble(tile = list(\r\n    i_tile,\r\n    i_tile %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix()\r\n  )) %>% \r\n    mutate(match = map_lgl(tile,~.x[,1] %>% paste(collapse = \"\") == left_right)) %>% \r\n    filter(match)\r\n  \r\n  if(nrow(i_list)==0) stop()\r\n  \r\n  i_tile <- i_list$tile[[1]]\r\n  \r\n  correct_tiles <- tibble(id = i_id, tile = list(i_tile)) %>% \r\n    bind_rows(correct_tiles,.)\r\n  \r\n}\r\n\r\ncorrect_tiles\r\n\r\n\r\n\r\nNow reapply the vertical orienter for each remaining column:\r\n\r\n\r\nfor(c in 2:12){ # c is column\r\n  for(r in 2:12){ # r is row\r\n    \r\n    i_id <- id_matrix[r,c]\r\n    up_id <- id_matrix[r-1,c]\r\n    \r\n    up_tile <- correct_tiles %>% \r\n      filter(id == up_id) %>% \r\n      pluck(\"tile\", 1)\r\n    \r\n    up_bottom <- up_tile[10,] %>% paste(collapse = \"\")\r\n    \r\n  i_tile <- tiles %>% \r\n    filter(id == i_id) %>% \r\n    pluck(\"tile\", 1)\r\n\r\n  i_list <- tibble(tile = list(\r\n    i_tile,\r\n    i_tile %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n    i_tile %>% flip_matrix() %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix()\r\n  )) %>% \r\n    mutate(match = map_lgl(tile,~.x[1,] %>% paste(collapse = \"\") == up_bottom)) %>% \r\n    filter(match)\r\n  \r\n  if(nrow(i_list)==0) stop()\r\n  \r\n  i_tile <- i_list$tile[[1]]\r\n      \r\n  correct_tiles <- tibble(id = i_id, tile = list(i_tile)) %>% \r\n    bind_rows(correct_tiles,.)\r\n  }\r\n}\r\n\r\n\r\n\r\nOkay, so theoretically we now have a directory of correctly oriented tiles! Now to strip out the border rows from each tile:\r\n\r\n\r\nborderless_tiles <- correct_tiles %>% \r\n  mutate(tile = map(tile,~.x[2:9,2:9]))\r\n\r\n\r\n\r\nAnd then row-bind each column together, then bind each column together into the final matrix.\r\n\r\n\r\ntile_matrix <- matrix(character(), nrow = 96)\r\n\r\nfor(c in 1:12){\r\n  column_matrix <- matrix(character(), ncol = 8)\r\n  \r\n  for(r in 1:12){\r\n    tile_id <- id_matrix[r,c]\r\n    \r\n    tile <- borderless_tiles %>% \r\n      filter(id == tile_id) %>% \r\n      pluck(\"tile\",1)\r\n    \r\n    column_matrix <- rbind(column_matrix,tile)\r\n  }\r\n  \r\n  tile_matrix <- cbind(tile_matrix,column_matrix)\r\n}\r\n\r\n\r\n\r\nNow to detect a seamonster! First, the monster:\r\n\r\n\r\nmonster <- tibble(x = c(\"                  # \", \r\n                        \"#    ##    ##    ###\",\r\n                        \" #  #  #  #  #  #   \")) %>% \r\n  mutate(x = str_split(x,\"\"),\r\n         row = row_number()) %>% \r\n  unnest_wider(x, names_sep = \"\") %>% \r\n  pivot_longer(cols = -row,names_to = \"col\") %>% \r\n  mutate(col = parse_number(col)) %>% \r\n  filter(value == \"#\")\r\n\r\n\r\n\r\nNow, we need to loop over the tile matrix, looking at every 20-wide + 3-tall matrix to see if it’s a monster. We’ll need to do this for every iteration of the tile matrix (rotates and flips).\r\n\r\n\r\nscan_tile_matrix_for_monsters <- function(tile_matrix,monster){\r\n  \r\n  monster_count <- 0\r\n  \r\n  for(c in 1:(ncol(tile_matrix)-19)){\r\n    \r\n    for(r in 1:(nrow(tile_matrix)-2)){\r\n      \r\n      x <- tile_matrix[r:(r+2),c:(c+19)]\r\n      \r\n      v <- map2_lgl(monster$row,monster$col, ~x[.x,.y]==\"#\") %>% all()\r\n      \r\n      if(v) monster_count <- monster_count + 1\r\n    }\r\n  }\r\n  \r\n  return(monster_count)\r\n}\r\n\r\nall_matrices <- list(\r\n  tile_matrix,\r\n  tile_matrix %>% rotate_matrix(),\r\n  tile_matrix %>% rotate_matrix() %>% rotate_matrix(),\r\n  tile_matrix %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix(),\r\n  flip_matrix(tile_matrix),\r\n  flip_matrix(tile_matrix) %>% rotate_matrix(),\r\n  flip_matrix(tile_matrix) %>% rotate_matrix() %>% rotate_matrix(),\r\n  flip_matrix(tile_matrix) %>% rotate_matrix() %>% rotate_matrix() %>% rotate_matrix()\r\n  )\r\n\r\nmonster_count <- map_dbl(all_matrices,scan_tile_matrix_for_monsters,monster)\r\n\r\nmonster_count\r\n\r\n\r\n\r\n\r\n[1]  0  0 43  0  0  0  0  0\r\n\r\n\r\n\r\nsum(tile_matrix == \"#\") - (max(monster_count) * nrow(monster))\r\n\r\n\r\n\r\n\r\n[1] 2002\r\n\r\nWhew, that was a doozy!\r\n\r\nDay 21\r\nhttps://adventofcode.com/2020/day/21\r\nDay twenty-one - Allergen Assessment!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Description —\r\n— Data —\r\n\r\n\r\ninput_21 <- read_lines(here(\"2020\", \"day-21.txt\"))\r\n\r\ninput_21_e <- read_lines(here(\"2020\",\"day-21-e.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\ningredient_list <- tibble(i = input_21) %>% \r\n  mutate(id = row_number()) %>% \r\n  separate(i, into = c(\"ingredient\",\"allergen\"), sep = \" \\\\(contains \") %>% \r\n  separate_rows(ingredient,sep = \" \") %>%\r\n  mutate(allergen = str_remove(allergen,\"\\\\)\")) %>% \r\n  separate_rows(allergen,sep = \", \")\r\n\r\n\r\n\r\n— Problem 1 —\r\nCount non-allergens. Spent some time thinking about this one, but basically I’m grouping by allergen and getting the ingredients that occur the most for each allergen. If it’s a single ingredient, that’s the one (and then eliminates that ingredient from being the allergen from any of the others). Loop through this to create a table of allergens.\r\n\r\n\r\ntop_allergens <- ingredient_list %>% \r\n  group_by(ingredient,allergen) %>% \r\n  summarise(n = n())%>% \r\n  group_by(allergen) %>% \r\n  slice_max(n) %>% \r\n  mutate(nn = n()) %>%  \r\n  arrange(nn,desc(n),allergen)\r\n\r\nallergen_options <- top_allergens\r\n\r\nallergen_df <- tibble()\r\n\r\nwhile(nrow(allergen_options)>0) {\r\n  \r\n  x <- allergen_options %>% \r\n    filter(nn == 1) %>% \r\n    select(ingredient, allergen)\r\n\r\n  allergen_df <- bind_rows(allergen_df, x)\r\n  \r\n  allergen_options <- allergen_options %>% \r\n    filter(!ingredient %in% allergen_df$ingredient, !allergen %in% allergen_df$allergen) %>% \r\n    group_by(allergen) %>% \r\n    mutate(nn = n())\r\n}\r\n\r\nnon_allergens <- ingredient_list %>% \r\n  filter(!ingredient %in% allergen_df$ingredient) %>% \r\n  distinct(ingredient,id)\r\n\r\nnrow(non_allergens)\r\n\r\n\r\n[1] 2428\r\n\r\n— Problem 2 —\r\n…is only to arrange the allergens in order? what?\r\n\r\n\r\nallergen_df %>% \r\n  arrange(allergen) %>% \r\n  pull(ingredient) %>% \r\n  paste(collapse = \",\")\r\n\r\n\r\n[1] \"bjq,jznhvh,klplr,dtvhzt,sbzd,tlgjzx,ctmbr,kqms\"\r\n\r\n…that was … easy?!\r\n\r\nDay 22\r\nhttps://adventofcode.com/2020/day/22\r\nDay twenty-two - Combat Crabs!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Description —\r\n— Data —\r\n\r\n\r\ninput_22 <- read_lines(here(\"2020\", \"day-22.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\ncards <- tibble(card = input_22) %>% \r\n  mutate(player = cumsum(str_detect(card,\"Player\"))) %>% \r\n  filter(card!=\"\",!str_detect(card,\"Player\")) %>% \r\n  mutate(card = parse_number(card))\r\n\r\nplayer_1 <- cards %>% \r\n  filter(player == 1) %>% \r\n  pull(card)\r\n\r\nplayer_2 <- cards %>% \r\n  filter(player == 2) %>% \r\n  pull(card)\r\n\r\n\r\n\r\n\r\n\r\ndraw_card <- function(player){ head(player,1) }\r\nremove_card <- function(player){ tail(player,-1) }\r\n\r\n\r\n\r\n— Problem 1 —\r\nCombat == “War” in my card game lexicon. Okay, looks straightforward enough:\r\n\r\n\r\ng1_player1 <- player_1\r\ng1_player2 <- player_2\r\n\r\nwhile(all(length(g1_player1)>0,length(g1_player2)>0)){\r\n  \r\n  card_p1 <- draw_card(g1_player1)\r\n  g1_player1 <- remove_card(g1_player1)\r\n  \r\n  card_p2 <- draw_card(g1_player2)\r\n  g1_player2 <- remove_card(g1_player2)\r\n  \r\n  if(card_p1 > card_p2) g1_player1 <- c(g1_player1,card_p1,card_p2)\r\n  \r\n  if(card_p2 > card_p1) g1_player2 <- c(g1_player2,card_p2,card_p1)\r\n  \r\n}\r\n\r\ng1_player1\r\n\r\n\r\n\r\n\r\n [1] 45 13 16  8 38 27 35 24 44 18 34 17 39 21 10  5 33 12 31  3 15  1\r\n[23] 50 49 26 23 48 40 43 14 42 11 41 30 37 19 47 32 28 20 36 29 46  7\r\n[45]  9  6 25  4 22  2\r\n\r\n\r\n\r\ng1_player2\r\n\r\n\r\n\r\n\r\n[1] 0\r\n\r\n\r\n\r\n(g1_player1 * 50:1) %>% sum()\r\n\r\n\r\n\r\n\r\n[1] 33421\r\n\r\n— Problem 2 —\r\nRecursive Combat? Le wot?\r\nRules:\r\nGame instantly ends in a win if a previous round within this game has the same cards in the same order in the same players decks, award win to player 1\r\nBegin round as usual by drawing the card.\r\nIf the number of cards remaining in the deck is more than the card they just drew, the winner of the round is determined by playing a new subgame of recursive combat.\r\nIf the number of cards remaining in the deck is less than the card they just drew (for either), the winner of the round is the player with the higher value card.\r\nLmao wtf okay…(insert meme)\r\n\r\n\r\ni <- 0\r\nrecursive_combat <- function(player_1,player_2){\r\n\r\n  i<<-i+1\r\n  \r\n  # Hold the early exit game state\r\n  deck_states <- c()\r\n  \r\n  game_deck_player_1 <- player_1\r\n  game_deck_player_2 <- player_2\r\n  \r\n  game_winner <- NULL\r\n  \r\n  loop <- 1\r\n  \r\n  while(loop != 0){\r\n    \r\n    # check deck states\r\n    player_1_score <- sum(game_deck_player_1 * rev(seq_along(game_deck_player_1)))\r\n    player_2_score <- sum(game_deck_player_2 * rev(seq_along(game_deck_player_2)))\r\n    \r\n    this_deck <- paste(player_1_score,player_2_score,sep = \"-\")\r\n    \r\n    if(this_deck %in% deck_states) {\r\n      \r\n      game_winner <- \"player_one\" \r\n      \r\n      break\r\n      \r\n    } else {\r\n      deck_states <- c(deck_states,this_deck)\r\n    }\r\n    \r\n    # draw cards\r\n    draw_player1 <- draw_card(game_deck_player_1)\r\n    game_deck_player_1 <- remove_card(game_deck_player_1)\r\n    \r\n    draw_player2 <- draw_card(game_deck_player_2)\r\n    game_deck_player_2 <- remove_card(game_deck_player_2)\r\n    \r\n    # Play recursive combat?\r\n    \r\n    if(length(game_deck_player_1)>=draw_player1 & length(game_deck_player_2)>=draw_player2) {\r\n      \r\n      round_winner <- recursive_combat(head(game_deck_player_1, draw_player1), \r\n                                       head(game_deck_player_2, draw_player2))$game_winner\r\n      \r\n    } else {\r\n      round_winner <- ifelse(draw_player1 > draw_player2, \"player_one\", \"player_two\")\r\n    }\r\n    \r\n    if(round_winner == \"player_one\") game_deck_player_1 <- c(game_deck_player_1,draw_player1,draw_player2)\r\n    \r\n    if(round_winner == \"player_two\") game_deck_player_2 <- c(game_deck_player_2,draw_player2,draw_player1)\r\n\r\n    loop <- ifelse(length(game_deck_player_1) == 0 | length(game_deck_player_2) == 0,0,1)\r\n    \r\n  }\r\n  \r\n  if(is.null(game_winner)){\r\n    game_winner <- ifelse(length(game_deck_player_1) > length(game_deck_player_2), \"player_one\", \"player_two\")\r\n  }\r\n  \r\n  return(list(game_winner = game_winner,\r\n              player_1 = game_deck_player_1, \r\n              player_2 = game_deck_player_2))\r\n}\r\n\r\nx <- recursive_combat(player_1,player_2)\r\n\r\n\r\n\r\n\r\n$game_winner\r\n[1] \"player_one\"\r\n\r\n$player_1\r\n [1] 18  5 47 38 49 21 34  1 45 33 32 23 39 36 27 16  2  6 43 40 42 24\r\n[23] 10  9 35 20 11  3 41 17 29 13 28 25 50 26 37  7 46 22 15  8 44 31\r\n[45] 14 12 48 19 30  4\r\n\r\n$player_2\r\nnumeric(0)\r\n\r\n\r\n\r\nsum(x$player_1 * rev(seq_along(x$player_1)))\r\n\r\n\r\n\r\n\r\n[1] 33651\r\n\r\n\r\nDay 23\r\nhttps://adventofcode.com/2020/day/23\r\nDay twenty-three - Crab Cups!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Description —\r\n— Data —\r\n\r\n\r\ninput_23 <- \"496138527\"\r\n\r\n\r\n\r\n— Cleaning —\r\n\r\n\r\nstart_order <- str_split(input_23,\"\") %>% unlist %>% as.numeric\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\np1 <- start_order\r\n\r\nfor(i in 1:100){\r\n  \r\n  current_cup <- p1[1]\r\n  \r\n  picked_up <- p1[2:4]\r\n  \r\n  other_cups <- tail(p1, -4)\r\n  \r\n  if(all(current_cup < other_cups)) {\r\n    \r\n    destination_cup <- max(other_cups)\r\n    \r\n  } else {\r\n    \r\n    destination_cup <- max(other_cups[(current_cup - other_cups) > 0])\r\n    \r\n  }\r\n  d_loc <- which(other_cups == destination_cup)\r\n\r\n  p1 <- c(\r\n    head(other_cups,d_loc),\r\n    picked_up,\r\n    tail(other_cups,-d_loc),\r\n    current_cup\r\n    )\r\n    \r\n}\r\n\r\none_loc <- which(p1 == 1)\r\n\r\nc(tail(p1,-one_loc),head(p1,one_loc-1)) %>% paste(collapse = \"\")\r\n\r\n\r\n\r\n\r\n[1] \"69425837\"\r\n\r\n— Problem 2 —\r\nTrying the naive solution first:\r\n\r\n\r\np2 <- c(start_order,seq.int(max(start_order),1000000))\r\n\r\nfor(i in 1:1000000){\r\n  \r\n  current_cup <- p2[1]\r\n  \r\n  picked_up <- p2[2:4]\r\n  \r\n  other_cups <- tail(p2, -4)\r\n  \r\n  if(all(current_cup < other_cups)) {\r\n    \r\n    destination_cup <- max(other_cups) \r\n    \r\n  } else {\r\n    \r\n    destination_cup <- max(other_cups[(current_cup - other_cups) > 0])\r\n    \r\n  }\r\n  d_loc <- which(other_cups == destination_cup)\r\n\r\n  p2 <- c(\r\n    head(other_cups,d_loc),\r\n    picked_up,\r\n    tail(other_cups,-d_loc),\r\n    current_cup\r\n    )\r\n}\r\n\r\none_loc <- which(p2 == 1)\r\n\r\np2[one_loc + c(1,2)]\r\n\r\n\r\n\r\nKilling it for being too slow.\r\nAttempt 2: trying to store the location of the next variable for each variable (as suggested by other languages’ linked lists)\r\n\r\n\r\np2 <- c(start_order,seq.int(max(start_order)+1,1000000)) %>% as.integer()\r\n\r\nnext_cups <- c(p2[-1],p2[1])\r\ncup_directory <- next_cups[order(p2)]\r\n\r\ncurrent_cup <- p2[1]\r\n\r\nfor (i in 1:10000000) {\r\n  \r\n  pickup_1 <- cup_directory[current_cup]\r\n  pickup_2 <- cup_directory[pickup_1]\r\n  pickup_3 <- cup_directory[pickup_2]\r\n  \r\n  destination_cup <- current_cup - 1:4\r\n  \r\n  destination_cup <- ifelse(\r\n    destination_cup <=0, \r\n    max(cup_directory) + destination_cup, \r\n    destination_cup)\r\n  \r\n  destination_cup <- destination_cup[!destination_cup %in% c(pickup_1,pickup_2,pickup_3)]\r\n  \r\n  destination_cup <- head(destination_cup, 1)\r\n  \r\n  cup_directory[current_cup] <- cup_directory[pickup_3]\r\n  # current now points to where third cup was pointing, removing three cups from loop\r\n  \r\n  cup_directory[pickup_3] <- cup_directory[destination_cup]\r\n  # third now points to where destination cup was pointing\r\n  \r\n  cup_directory[destination_cup] <- pickup_1\r\n  # destination cup now points at the first cup in the pickup\r\n  \r\n  current_cup <- cup_directory[current_cup]\r\n  # move pointer to where the current cup is pointing\r\n}\r\n\r\nx1 <- cup_directory[1]\r\nx2 <- cup_directory[x1]\r\n\r\nprod(x1,x2)\r\n\r\n\r\n\r\n\r\n[1] 218882971435\r\n\r\nAbout three minutes to run the loop, so not bad!\r\n\r\nDay 24\r\nhttps://adventofcode.com/2020/day/24\r\nDay twenty-four - Lobby Layout!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n})\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\ninput_24 <- read_lines(here(\"2020\", \"day-24.txt\"))\r\ninput_24_e <- read_lines(here(\"2020\", \"day-24-e.txt\"))\r\n\r\n\r\n\r\n— Cleaning —\r\nHex grids coordinates c/o https://www.redblobgames.com/grids/hexagons/\r\n\r\n\r\ndirections_e <- tibble(i = input_24_e) %>% \r\n  mutate(i = str_extract_all(i,\"se|sw|nw|ne|e|w\"),\r\n         id = row_number()) %>% \r\n  unnest_longer(i)\r\n\r\ndirections <- tibble(i = input_24) %>% \r\n  mutate(i = str_extract_all(i,\"se|sw|nw|ne|e|w\"),\r\n         id = row_number()) %>% \r\n  unnest_longer(i)\r\n\r\nhex_coordinates <- list(e = c(1,-1,0),\r\n                        se = c(0,-1,1),\r\n                        sw = c(-1,0,1),\r\n                        w = c(-1,1,0),\r\n                        nw = c(0,1,-1),\r\n                        ne = c(1,0,-1)) %>% \r\n  enframe() %>% \r\n  unnest_wider(value,names_sep = \"\") %>% \r\n  rename(dx = value1, dy = value2, dz = value3)\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\ntile_locations <- directions %>% \r\n  left_join(hex_coordinates, by = c(\"i\" = \"name\")) %>% \r\n  group_by(id) %>% \r\n  summarise(x = sum(dx),\r\n            y = sum(dy),\r\n            z = sum(dz)) %>% \r\n  group_by(x,y,z) %>% \r\n  summarise(n = n()) %>% \r\n  ungroup()\r\n\r\nsum(tile_locations$n == 1)\r\n\r\n\r\n\r\n\r\n[1] 528\r\n\r\n— Problem 2 — Another gd game of life problem?! FFS. Assuming that prev problem is day zero.\r\n\r\n\r\ncurrent_state <- tile_locations %>% \r\n  mutate(colour = ifelse(n == 1, \"black\", \"white\")) %>% \r\n  filter(colour == \"black\")\r\n\r\nget_tile <- function(x,y,z,day){\r\n  current_state$colour[current_state$x == x & current_state$y == y & current_state$z == z]\r\n}\r\n\r\nget_tile <- memoise::memoise(get_tile)\r\n\r\nget_adjacent_tiles <- function(x,y,z, day){\r\n  \r\n  nx <- hex_coordinates$dx + x\r\n  ny <- hex_coordinates$dy + y\r\n  nz <- hex_coordinates$dz + z\r\n  \r\n  neighbours <- pmap(list(nx,ny,nz),get_tile,day)\r\n  \r\n  sum(unlist(neighbours) == \"black\", na.rm = TRUE)\r\n  \r\n}\r\n\r\nfor(day in 1:100){\r\n  \r\n  grid_range <- range(current_state[c('x','y','z')])\r\n  \r\n  search_grid <- seq.int(from = grid_range[1]-1, to = grid_range[2]+1) %>% \r\n    crossing(x = ., y = ., z = .) %>% \r\n    filter((x + y + z) == 0) %>%\r\n    left_join(\r\n      current_state %>% select(x,y,z,colour),\r\n      by = c(\"x\",\"y\",\"z\")\r\n    ) %>% \r\n    mutate(colour = replace_na(colour,\"white\"),\r\n           neighbours = pmap_dbl(list(x,y,z), get_adjacent_tiles, day),\r\n           new_colour = case_when(colour == \"black\" & (neighbours == 0 | neighbours > 2) ~ \"white\",\r\n                                  colour == \"white\" & (neighbours == 2) ~ \"black\",\r\n                                  TRUE ~ colour))\r\n  \r\n  current_state <- search_grid %>% \r\n    select(x,y,z,colour = new_colour) %>% \r\n    filter(colour == \"black\")\r\n  \r\n  if(day %% 10 == 0) message(day)\r\n  \r\n}\r\n\r\nnrow(current_state)\r\n\r\n\r\n\r\n\r\n[1] 4200\r\n\r\n\r\nDay 25\r\nhttps://adventofcode.com/2020/day/25\r\nDay twenty-five - Combo Breaker!\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n\r\n  knitr::opts_chunk$set(echo = TRUE)\r\n  options(scipen = 9999999)\r\n  options(dplyr.summarise.inform = FALSE)\r\n})\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\ninput_25 <- c(2069194,16426071)\r\n\r\n\r\n\r\n— Problem 1 —\r\n\r\n\r\nfind_loops <- function(input){\r\n  \r\n  goal_keys <- numeric(2)\r\n  v <- 1\r\n  i <- 0\r\n  \r\n  while(any(goal_keys %in% 0)){\r\n   i <- i+1\r\n   v <- (v * 7) %% 20201227\r\n   \r\n   if(v == input[1]) goal_keys[1] <- i\r\n   if(v == input[2]) goal_keys[2] <- i\r\n  }\r\n  \r\n  return(goal_keys)\r\n}\r\n\r\nloop_sizes <- find_loops(input_25)\r\n\r\nencrypt_key <- function(public_key,loop_size){\r\n  \r\n  v <- 1\r\n  \r\n  for(i in seq_len(loop_size)) v <- (v * public_key) %% 20201227\r\n  \r\n  v\r\n}\r\n\r\nencrypt_key(input_25[1],loop_sizes[2])\r\n\r\n\r\n\r\n\r\n[1] 11576351\r\n\r\n\r\nDay 26\r\nhttps://adventofcode.com/2020/day/26\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(httr)\r\n})\r\n\r\noptions(dplyr.summarise.inform = FALSE)\r\nknitr::opts_chunk$set(echo = TRUE)\r\n\r\n\r\n\r\n\r\n\r\nstars <- httr::GET(\"https://adventofcode.com/2020/leaderboard/private/view/1032765.json\",\r\n                   httr::set_cookies(session = Sys.getenv(\"session_cookie\"))) %>% \r\n  content() %>% \r\n  as_tibble() %>% \r\n  hoist(\"members\",\r\n        \"user_name\"=\"name\",\r\n        \"user_id\"=\"id\",\r\n        \"aoc_score\"=\"local_score\",\r\n        \"completed_stars\"=\"completion_day_level\",\r\n        \"total_stars\" = \"stars\"\r\n        ) %>% \r\n  unnest_longer('completed_stars',indices_to = \"day\") %>% \r\n  unnest_longer(\"completed_stars\",indices_to = \"star\") %>% \r\n  unnest_longer(\"completed_stars\",indices_include = FALSE) %>% \r\n  select(\"user_name\",\"user_id\",\"aoc_score\",\"total_stars\",\"day\",\"star\",\"timestamp\"=\"completed_stars\") %>%\r\n  filter(!is.na(star)) %>% \r\n  pivot_wider(names_from = star, values_from = timestamp, names_glue = \"star{star}_ts\") %>% \r\n  mutate_at(c(\"star1_ts\",\"star2_ts\"),~ as.numeric(.x) %>% lubridate::as_datetime(tz = \"America/Toronto\")) %>% \r\n  mutate(time_to_star2 = (star2_ts-star1_ts) %>% round(1)) %>% \r\n  arrange(desc(as.numeric(day))) %>% \r\n  select(user_name,total_stars,aoc_score,day,star1_ts,star2_ts,everything())\r\n\r\nstars\r\n\r\n\r\n# A tibble: 735 x 8\r\n   user_name       total_stars aoc_score day   star1_ts           \r\n   <chr>                 <int>     <int> <chr> <dttm>             \r\n 1 Farhan Reynaldo          50      5466 25    2020-12-25 04:48:36\r\n 2 Nathan Moore             50      5691 25    2020-12-26 06:13:33\r\n 3 Darrin Speegle           50      5839 25    2020-12-25 00:24:22\r\n 4 Jaroslaw Nirski          50      6057 25    2020-12-31 06:54:14\r\n 5 Colin Rundel             50      5953 25    2020-12-25 04:45:26\r\n 6 Riinu Pius               37      4129 25    2020-12-25 01:31:55\r\n 7 @ClareHorscroft          50      6130 25    2020-12-25 04:14:47\r\n 8 TJ Mahr                  47      5299 25    2020-12-28 10:04:16\r\n 9 @_TanHo                  50      6040 25    2020-12-25 08:29:27\r\n10 @_mnar99                 44      4767 25    2020-12-25 15:55:09\r\n# ... with 725 more rows, and 3 more variables: star2_ts <dttm>,\r\n#   user_id <chr>, time_to_star2 <drtn>\r\n\r\nleaderboard <- stars %>% \r\n  group_by(user_name,user_id,aoc_score,total_stars) %>% \r\n  summarise(\r\n    median_star2 = median(time_to_star2,na.rm = TRUE) %>% `units<-`(\"mins\") %>%  round(1),\r\n    mean_star2 = mean(time_to_star2,na.rm = TRUE) %>% `units<-`(\"mins\") %>% round(1)) %>% \r\n  ungroup() %>% \r\n  arrange(desc(total_stars),median_star2)\r\n\r\nleaderboard\r\n\r\n\r\n# A tibble: 54 x 6\r\n   user_name     user_id aoc_score total_stars median_star2 mean_star2\r\n   <chr>         <chr>       <int>       <int> <drtn>       <drtn>    \r\n 1 Colin Rundel  433087       5953          50  17.6 mins    89.0 mins\r\n 2 Tom Jemmett   190599       5770          50  20.7 mins   219.8 mins\r\n 3 Darrin Speeg~ 387786       5839          50  25.8 mins   320.7 mins\r\n 4 Ildikó Czell~ 267475       5926          50  28.7 mins   412.5 mins\r\n 5 pritikadasgu~ 1020187      5818          50  31.0 mins    96.1 mins\r\n 6 Jaroslaw Nir~ 443063       6057          50  33.1 mins   447.1 mins\r\n 7 Emil Hvitfel~ 433239       5922          50  34.5 mins   913.2 mins\r\n 8 @ClareHorscr~ 1037870      6130          50  35.2 mins   594.9 mins\r\n 9 @_TanHo       1032765      6040          50  86.0 mins   233.8 mins\r\n10 Nerwosolek    1047933      5657          50 151.9 mins   653.2 mins\r\n# ... with 44 more rows\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:05:56-05:00"
    },
    {
      "path": "2021.html",
      "title": "Solutions for AOC 2021",
      "description": "My second Advent of Code!\n",
      "author": [],
      "contents": "\r\n\r\nDay 1\r\nhttps://adventofcode.com/2021/day/1\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\nDay one! https://adventofcode.com/2021/day/1\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(1)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-01-input.txt\"))\r\n\r\n\r\n\r\n— Problem 1 —\r\nSum. Don’t forget to as.numeric your inputs, doofus.\r\n\r\n\r\nx <- tibble(x = as.numeric(input)) |>  \r\n  mutate(\r\n    increase = x > lag(x)\r\n  )\r\nsum(x$increase, na.rm = TRUE)\r\n\r\n\r\n[1] 1832\r\n\r\n— Problem 2 —\r\nRolling sums.\r\n\r\n\r\ny <- tibble(x = as.numeric(input)) |> \r\n  mutate(\r\n    y = lead(x),\r\n    z = lead(x,2),\r\n    sum = x + y + z\r\n  ) |> \r\n  filter(!is.na(sum)) |> \r\n  mutate(increase = sum > lag(sum))\r\n\r\nsum(y$increase, na.rm = TRUE)\r\n\r\n\r\n[1] 1858\r\n\r\n\r\nDay 2\r\nhttps://adventofcode.com/2021/day/2\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(2)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-02-input.txt\"))\r\n\r\n\r\n\r\nBasic cleanup - into a dataframe of direction/count and converting negatives for depth\r\n\r\n\r\nx <- tibble(x = input) |> \r\n  separate(x,into = c(\"direction\",\"count\"), sep = \" \") |> \r\n  mutate(\r\n    count = as.numeric(count),\r\n    count = case_when(direction == \"up\" ~ -count, TRUE ~ count)) \r\nhead(x)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  direction count\r\n  <chr>     <dbl>\r\n1 forward       8\r\n2 forward       3\r\n3 down          8\r\n4 down          2\r\n5 up           -1\r\n6 up           -4\r\n\r\n— Part 1 —\r\n\r\n\r\np1 <- x |> \r\n  group_by(direction = ifelse(direction == \"forward\",\"horizontal\",\"depth\")) |> \r\n  summarise(count = sum(count))\r\np1\r\n\r\n\r\n# A tibble: 2 x 2\r\n  direction  count\r\n  <chr>      <dbl>\r\n1 depth       1018\r\n2 horizontal  1823\r\n\r\np1$count[1] * p1$count[2]\r\n\r\n\r\n[1] 1855814\r\n\r\nforward = 1823\r\ndepth = 1018\r\n— Part 2 —\r\nFor part two we already know the horizontal so we need to do some cleanup to get the vertical one (calculate the aim at any given point via cumulative sum) and then recalculate\r\n\r\n\r\np2 <- x |> \r\n  mutate( aim = ifelse(direction == \"forward\", 0, count), \r\n          aim = cumsum(aim)) |> \r\n  filter(direction == \"forward\") |> \r\n  summarise(depth = sum(aim * count))\r\n\r\np2\r\n\r\n\r\n# A tibble: 1 x 1\r\n    depth\r\n    <dbl>\r\n1 1012318\r\n\r\np2$depth * 1823\r\n\r\n\r\n[1] 1845455714\r\n\r\n\r\nDay 3\r\nhttps://adventofcode.com/2021/day/3\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(3)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-03-input.txt\"))\r\n\r\n\r\n\r\nCleaning the data to a tibble with columns for each digit, because I find that to be the most useful/workable input format\r\n\r\n\r\ni <- tibble(x = input) |> \r\n  mutate(y = strsplit(x,\"\"),\r\n         x = NULL) %>%\r\n  {suppressMessages(unnest_wider(.,y))}\r\n\r\ni\r\n\r\n\r\n# A tibble: 1,000 x 12\r\n   ...1  ...2  ...3  ...4  ...5  ...6  ...7  ...8  ...9  ...10 ...11\r\n   <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>\r\n 1 0     0     0     0     0     1     1     1     0     0     0    \r\n 2 0     0     0     0     0     1     1     1     1     1     0    \r\n 3 0     1     0     0     1     1     0     0     0     0     0    \r\n 4 0     0     0     0     0     0     0     0     0     0     1    \r\n 5 0     1     0     0     0     0     1     0     0     1     1    \r\n 6 1     0     1     0     0     0     1     0     0     0     0    \r\n 7 1     0     1     0     0     0     0     0     1     1     0    \r\n 8 0     1     0     0     1     1     0     0     1     1     1    \r\n 9 0     0     1     0     0     0     1     1     1     0     1    \r\n10 1     1     0     0     1     0     1     1     0     0     1    \r\n# ... with 990 more rows, and 1 more variable: ...12 <chr>\r\n\r\n— Part 1 —\r\nTaking the tidyverse way out here by summarising and counting…which may bite me…\r\n\r\n\r\np1 <- i |> \r\n  mutate(x = row_number()) |> \r\n  pivot_longer(-x,names_to = \"y\") |> \r\n  mutate(y = str_remove(y,\"...\") |> as.numeric()) |> \r\n  group_by(y) |> \r\n  count(value)\r\n\r\nhead(p1)\r\n\r\n\r\n# A tibble: 6 x 3\r\n# Groups:   y [3]\r\n      y value     n\r\n  <dbl> <chr> <int>\r\n1     1 0       508\r\n2     1 1       492\r\n3     2 0       493\r\n4     2 1       507\r\n5     3 0       499\r\n6     3 1       501\r\n\r\ngamma <- p1 |> \r\n  slice_max(n) |> \r\n  pull(value) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\n\r\nepsilon <- p1 |> \r\n  slice_min(n) |> \r\n  pull(value) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\n\r\ngamma * epsilon\r\n\r\n\r\n[1] 4118544\r\n\r\n— Part 2 —\r\nTidyverse bit me a bit here, going back and adding parsing functions and reducing them over each column of the matrix.\r\n\r\n\r\np2 <- as.matrix(i) |> unname()\r\n\r\nparser <- function(m, pos, most = TRUE){\r\n  if(is.null(dim(m))) return(m)\r\n  \r\n  keep <- .mostleast(m[,pos], most)\r\n  return(m[m[,pos] == keep,])\r\n}\r\n\r\n.mostleast <- function(v, most = TRUE){\r\n  one <- sum(v == \"1\")\r\n  zero <- sum(v == '0')\r\n  \r\n  if(most) return(ifelse(one >= zero, \"1\", \"0\"))\r\n  return(ifelse(one < zero, \"1\", \"0\"))\r\n}\r\n\r\noxygen <- reduce(seq_len(ncol(p2)), parser, .init = p2, most = TRUE) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\n\r\nco2 <- reduce(seq_len(ncol(p2)), parser, .init = p2, most = FALSE) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\n\r\noxygen * co2\r\n\r\n\r\n[1] 3832770\r\n\r\n— Part 1 redux —\r\nwith the function built for part 2, revisiting part 1 for extra-ish credit:\r\n\r\n\r\ngamma2 <- map(seq_len(ncol(p2)), ~.mostleast(p2[,.x], most = TRUE)) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\nepsilon2 <- map(seq_len(ncol(p2)),~.mostleast(p2[,.x], most = FALSE)) |> \r\n  paste(collapse = \"\") |> \r\n  strtoi(base = 2L)\r\n\r\ngamma2 * epsilon2\r\n\r\n\r\n[1] 4118544\r\n\r\nI can largely see why I think of the tidy/pivot way first <U+0001F602>\r\n\r\nDay 4\r\nhttps://adventofcode.com/2021/day/4\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(4)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-04-input.txt\"))\r\n\r\n\r\n\r\nI find it easier to parse stuff when it’s in tibbles, this happens to be the fastest way for me to lump all the boards together in my mind. Also creating a score matrix of the same length.\r\n\r\n\r\nbingo_calls <- input[[1]] |> strsplit(\",\") |> unlist() |> as.numeric()\r\n\r\nbingo_boards <- tibble(x = input[-1]) |> \r\n  mutate(board_id = cumsum(x == \"\")) |> \r\n  filter(x != \"\") |> \r\n  group_by(board_id) |> \r\n  summarise(boards = paste(x, collapse = \" \") |> str_squish()) |> \r\n  mutate(boards = strsplit(boards, \"\\\\s+\") |> \r\n           map(~as.numeric(.x) |> matrix(ncol = 5, byrow = TRUE)),\r\n         selected = list(matrix(rep(0,25),ncol = 5))\r\n  )\r\n\r\n\r\n\r\n— Part 1 —\r\nCreate a function to check a bingo board for success, and a different function to call the bingo number. Then a nested loop to call all of the boards for each bingo number, breaking if any are successful\r\n\r\n\r\n# id_matrix <- bingo_boards$boards[[1]]\r\n# score_matrix <- matrix(rep(0,25),ncol = 5)\r\n# bingo_call <- 97\r\n\r\ncheck_board <- function(m){\r\n  rows <- rowSums(m,na.rm = TRUE)\r\n  cols <- colSums(m, na.rm = TRUE)\r\n  diagon <- sum(m[1,1],m[2,2],m[3,3],m[4,4],m[5,5])\r\n  alley <- sum(m[5,1],m[4,2],m[3,3],m[2,4],m[1,5])\r\n  \r\n  if(any(rows == 5, cols == 5, diagon == 5, alley == 5)) return(TRUE)\r\n  \r\n  return(FALSE)\r\n}\r\n\r\ncall_number <- function(score_matrix, bingo_call, id_matrix){\r\n  \r\n  l <- which(id_matrix %in% bingo_call)\r\n  score_matrix[l] <- 1\r\n  return(score_matrix)\r\n}\r\n\r\nboards <- bingo_boards$boards\r\nscores <- bingo_boards$selected\r\n\r\nfor (n in bingo_calls){\r\n  for (b in bingo_boards$board_id){\r\n    scores[[b]] <- call_number(scores[[b]], bingo_call = n, id_matrix = boards[[b]])\r\n    if(check_board(scores[[b]])) break\r\n  }\r\n  if(check_board(scores[[b]])) break\r\n}\r\n\r\n\r\n\r\n\r\n\r\nsum((scores[[b]] == 0) * (boards[[b]])) * n\r\n\r\n\r\n[1] 34506\r\n\r\n— Part 2 —\r\nSame as before but storing which bingo call resulted in a success state.\r\n\r\n\r\nboards2 <- bingo_boards$boards\r\nscores2 <- bingo_boards$selected\r\n\r\nboard_status <- rep(0,100)\r\ncounter <- 1\r\nfor (n in bingo_calls){\r\n  for (b in bingo_boards$board_id){\r\n    if(check_board(scores2[[b]])) next\r\n    scores2[[b]] <- call_number(scores2[[b]], bingo_call = n, id_matrix = boards2[[b]])\r\n    if(check_board(scores2[[b]])) board_status[b] <- counter\r\n  }\r\n  if(all(sapply(scores2, check_board))) break\r\n  counter <- counter + 1\r\n}\r\n\r\nlast <- which.max(board_status)\r\n\r\nsum((scores2[[last]] == 0) * (boards2[[last]])) * n\r\n\r\n\r\n[1] 7686\r\n\r\n\r\nDay 5\r\nhttps://adventofcode.com/2021/day/5\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  library(tantastic)\r\n  \r\n  tantastic::fontimport_bai_jamjuree()\r\n  tantastic::fontimport_plex_condensed()\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(5)\r\n\r\n\r\n\r\n\r\n\r\ni <- readLines(here::here(\"2021/day-05-input.txt\"))\r\n\r\n\r\n\r\n\r\n\r\ninput <- tibble(x = i) |> \r\n  extract(x, c(\"x1\",\"y1\",\"x2\",\"y2\"),regex = \"([0-9]+),([0-9]+) -> ([0-9]+),([0-9]+)\",convert = TRUE) |> \r\n  mutate(\r\n    line_id = row_number()\r\n  )\r\n\r\n\r\n\r\n— Part 1 —\r\nUsing map2, create a nested list for each point and then unnest and group-by+count the duplicates\r\n\r\n\r\np1 <- input |> \r\n  filter(x1 == x2 | y1 == y2) |> \r\n  mutate(\r\n    x = map2(x1,x2,~.x:.y),\r\n    y = map2(y1,y2,~.x:.y)\r\n  ) |> \r\n  select(line_id, x, y) |> \r\n  unnest(c(x,y)) |> \r\n  group_by(x,y) |> \r\n  summarise(\r\n    dupl = n()\r\n  ) |> \r\n  filter(\r\n    dupl > 1\r\n  )\r\n\r\nnrow(p1)\r\n\r\n\r\n[1] 5442\r\n\r\n— Part 2 —\r\nVery lucky that this solution generalizes by just removing the filter!\r\n\r\n\r\np2 <- input |> \r\n  mutate(\r\n    x = map2(x1,x2,~.x:.y),\r\n    y = map2(y1,y2,~.x:.y)\r\n  ) |> \r\n  select(line_id, x, y) |> \r\n  unnest(c(x,y)) |> \r\n  group_by(x,y) |> \r\n  summarise(\r\n    dupl = n()\r\n  ) |> \r\n  filter(\r\n    dupl > 1\r\n  )\r\n\r\nnrow(p2)\r\n\r\n\r\n[1] 19571\r\n\r\nI am unbelievably excited to have placed in the top 500!\r\nAnd per Joe’s request, a plotses!\r\n\r\n\r\ninput |> \r\n  mutate(\r\n    x = map2(x1,x2,~.x:.y),\r\n    y = map2(y1,y2,~.x:.y)\r\n  ) |> \r\n  select(line_id, x, y) |> \r\n  unnest(c(x,y)) |> \r\n  ggplot(aes(x = x, y = y, color = line_id, fill = line_id, group = line_id)) + \r\n  geom_line(alpha = 0.75) + \r\n  labs(\r\n    title = \"Advent Of Code Day 5: Hydrothermal Venture\",\r\n    caption = \"@_TanHo\"\r\n  ) + \r\n  tantastic::theme_tantastic() + \r\n  theme(\r\n    axis.title.x = element_blank(),\r\n    axis.title.y = element_blank(),\r\n    legend.position = \"none\",\r\n    axis.text.x = element_blank(),\r\n    axis.text.y = element_blank(),\r\n    plot.title = element_text(hjust = 0.5)\r\n  )\r\n\r\n\r\n\r\n\r\n\r\nDay 6\r\nhttps://adventofcode.com/2021/day/6\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(6)\r\n\r\n\r\n\r\n\r\n\r\nexample <- \"3,4,3,1,2\" |> \r\n  strsplit(\",\") |> \r\n  unlist() |> \r\n  as.numeric()\r\n\r\ninput <- readLines(here::here(\"2021/day-06-input.txt\")) |> \r\n  strsplit(\",\") |> \r\n  unlist() |> \r\n  as.numeric()\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nv <- example\r\n\r\nfish_day <- function(v,...){\r\n  \r\n  new_v <- v - 1\r\n  \r\n  if(!any(new_v < 0)) return(new_v)\r\n  \r\n  new_index <- new_v < 0\r\n  \r\n  new_v[new_index] <- 6\r\n  \r\n  new_v <- c(new_v, rep(8,sum(new_index)))\r\n  \r\n  return(new_v)\r\n}\r\n\r\nv <- input\r\nfor (i in 1:80) {\r\n  v <- fish_day(v)\r\n}\r\n\r\n\r\n\r\n— Part 2 —\r\nNaive solution very slow. Count the number at each position instead. Much fast. Such wow.\r\n\r\n\r\nfish_day_two <- function(p){\r\n  \r\n  new <- p |> \r\n    select(-n) |> \r\n    full_join(\r\n      p |> mutate(x = x - 1),\r\n      by = \"x\"\r\n    ) |> \r\n    mutate(\r\n      n = replace_na(n,0)\r\n    )\r\n  \r\n  new$n[new$x == 6] <- new$n[new$x == -1] + new$n[new$x == 6]\r\n  new$n[new$x == 8] <- new$n[new$x == -1]\r\n  \r\n  p <- new |> filter(x>=0)\r\n}\r\n\r\np <- tibble(x = input) |> \r\n  group_by(x) |> \r\n  count() |> \r\n  ungroup() |> \r\n  right_join(\r\n    tibble(x = 0:8), by = \"x\"\r\n  ) |> \r\n  mutate(\r\n    n = replace_na(n,0)\r\n  )\r\n\r\nfor (i in 1:256) {\r\n  p <- fish_day_two(p)\r\n}\r\n\r\n\r\n\r\n\r\nDay 7\r\nhttps://adventofcode.com/2021/day/7\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\naoc.elf::aoc_get(7)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-07-input.txt\")) |> \r\n  strsplit(\",\") |> \r\n  unlist() |> \r\n  as.numeric()\r\n\r\ninput <- \"16,1,2,0,4,2,7,1,2,14\" |> \r\n  strsplit(\",\") |> \r\n  unlist() |> \r\n  as.numeric()\r\n\r\n\r\n\r\n— Part 1 —\r\nCost is difference in inputs, loop over range of inputs to find total cost for all options.\r\n\r\n\r\nr <- range(input)\r\ns <- seq(r[1],r[2])\r\nsums <- map_dbl(s, ~sum(abs(input-.x)))\r\nsums[which.min(sums)]\r\n\r\n\r\n[1] 37\r\n\r\n— Part 2 —\r\nCost is triangular number (that took a googling lol), loop over range to find total cost\r\n\r\n\r\nr <- range(input)\r\ns <- seq(r[1],r[2])\r\nsums <- map_dbl(s, ~sum(abs(input-.x)*(abs(input-.x)+1)/2))\r\nsums[which.min(sums)]\r\n\r\n\r\n[1] 168\r\n\r\n\r\nDay 8\r\nhttps://adventofcode.com/2021/day/8\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 8, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- tibble(x = readLines(here::here(\"2021/day-08-input.txt\"))) |> \r\n  separate(x,into = c(\"pattern\",\"output\"),sep = \"\\\\|\") |>\r\n  mutate_all(~str_squish(.x) |> strsplit(\" \"))\r\n  \r\n\r\nexample <- \r\n  \"acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf\" %>%\r\n  tibble(x = .) |> \r\n  separate(x,into = c(\"pattern\",\"output\"),sep = \"\\\\|\") |>\r\n  mutate_all(~str_squish(.x) |> strsplit(\" \"))\r\n\r\nexample_two <- tibble(x = c(\r\n  \"be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe\",\r\n  \"edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc\",\r\n  \"fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg\",\r\n  \"fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb\",\r\n  \"aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea\",\r\n  \"fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb\",\r\n  \"dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe\",\r\n  \"bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef\",\r\n  \"egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb\",\r\n  \"gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce\")) |> \r\n  separate(x,into = c(\"pattern\",\"output\"),sep = \"\\\\|\") |>\r\n  mutate_all(~str_squish(.x) |> strsplit(\" \"))\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\np1 <- input$output\r\n# p1 <- example_two$output\r\n\r\nall_outs <- tibble(o = unlist(p1)) |> \r\n  mutate(\r\n    n = str_length(o)\r\n  ) |> \r\n  filter(\r\n    n %in% c(2,3,4,7)\r\n  )\r\nall_outs\r\n\r\n\r\n\r\n— Part 2 —\r\nTook the long and naive approach of identifying each segment because #completionist (ugh). This probably made my life a lot harder.\r\n\r\n\r\nv <- unlist(example$pattern)\r\no <- unlist(example$output)\r\n\r\nvsplit <- function(v){unlist(strsplit(v,\"\"))}\r\n\r\nvfind <- function(v, n, negate = FALSE) {\r\n  if(negate) v[!str_length(v) %in% n]\r\n  v[str_length(v) %in% n]\r\n  }\r\n\r\ndecode_display <- function(v,o){\r\n  \r\n  top <- vsplit(vfind(v,3))[!vsplit(vfind(v,3)) %in% vsplit(vfind(v,2))]\r\n  # bottom_right <- vsplit(vfind(v,2))[\r\n  .six <- vfind(v,6)[\r\n      ! (str_detect(vfind(v,6),vsplit(vfind(v,2))[1]) &\r\n           str_detect(vfind(v,6),vsplit(vfind(v,2))[2]))\r\n    ]\r\n  \r\n  \r\n  bottom_right <- vsplit(vfind(v,2))[stringr::str_detect(.six, vsplit(vfind(v,2)))]\r\n  \r\n  top_right <- vsplit(vfind(v,2))[!str_detect(.six,vsplit(vfind(v,2)))]\r\n\r\n  .three <- vfind(v,5)[\r\n    str_detect(vfind(v,5),top) &\r\n    str_detect(vfind(v,5),bottom_right) &\r\n    str_detect(vfind(v,5),top_right)\r\n  ]\r\n  .four <- vfind(v,4)\r\n  \r\n  .middle_left <- vsplit(vfind(v,4))[\r\n    !vsplit(vfind(v,4)) %in% c(top_right, bottom_right)\r\n    ]\r\n  \r\n  middle <- .middle_left[str_detect(.three, .middle_left)]\r\n  \r\n  top_left <- .middle_left[!str_detect(.three, .middle_left)]\r\n  \r\n  .nine <- vfind(v,6)[\r\n    str_detect(vfind(v,6), middle) &\r\n    str_detect(vfind(v,6), top_right)\r\n  ]\r\n  \r\n  bottom <- vsplit(.nine)[!vsplit(.nine) %in% c(top, top_right, top_left, middle, bottom_right)]\r\n  \r\n  bottom_left <- vsplit(vfind(v,7))[\r\n    !vsplit(vfind(v,7)) %in% c(top, top_left, top_right, bottom, bottom_right, middle)\r\n  ]\r\n  \r\n  mapping <- list(\r\n    \"0\" = c(top,top_right, top_left,bottom_left,bottom_right,bottom),\r\n    \"1\" = c(top_right, bottom_right),\r\n    \"2\" = c(top, top_right, middle, bottom_left, bottom),\r\n    \"3\" = c(top, top_right, middle, bottom_right, bottom),\r\n    \"4\" = c(top_left, top_right, middle, bottom_right),\r\n    \"5\" = c(top, top_left, middle, bottom_right, bottom),\r\n    \"6\" = c(top, top_left, middle, bottom_left, bottom_right, bottom),\r\n    \"7\" = c(top, top_right, bottom_right),\r\n    \"8\" = c(top, top_left, top_right, middle, bottom_left,bottom_right,bottom),\r\n    \"9\" = c(top, top_left, top_right, middle, bottom_right,bottom)\r\n  ) |> \r\n    map_chr(~sort(.x) |> paste(collapse = \"\")) |> \r\n    enframe() |> \r\n    mutate(name = as.numeric(name))\r\n  \r\n  display <- \r\n    tibble(value = o |> map_chr(~vsplit(.x) |> sort() |> paste(collapse = \"\"))) |> \r\n    left_join(mapping, by = \"value\") |> \r\n    pull(name) |> \r\n    paste(collapse = \"\") |> \r\n    as.numeric()\r\n  \r\n  return(display)\r\n}\r\n\r\nmap2(input$pattern,input$output,decode_display) |> unlist() |> sum()\r\n\r\n\r\n[1] 1096964\r\n\r\n\r\nDay 9\r\nhttps://adventofcode.com/2021/day/9\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 9, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-09-input.txt\")) |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric)\r\n\r\ninput <- do.call(rbind, input)\r\n\r\nexample <- c(2199943210,\r\n             3987894921,\r\n             9856789892,\r\n             8767896789,\r\n             9899965678) |> \r\n  as.character() |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric)\r\n\r\nexample <- do.call(rbind,example)\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nm <- input\r\n\r\ncheck_lowpoint <- function(x,y, m){\r\n      \r\n      r <- NULL\r\n      l <- NULL\r\n      d <- NULL\r\n      u <- NULL\r\n  \r\n      max_x <- nrow(m)\r\n      max_y <- ncol(m)\r\n      \r\n      if(x > 1) l <- m[x,y] < m[x-1,y]\r\n      if(y > 1) u <- m[x,y] < m[x,y-1]\r\n      \r\n      if(x < max_x) r <- m[x,y] < m[x+1,y]\r\n      if(y < max_y) d <- m[x,y] < m[x,y+1]\r\n      \r\n      if(all(c(r,l,u,d))) return(list(x = x, y = y))\r\n      return(NULL)\r\n}\r\n\r\nindices <- crossing(x = seq_len(nrow(m)), y = seq_len(ncol(m)))\r\n\r\nresult <- map2_dfr(indices$x, indices$y, check_lowpoint, m)\r\n\r\nsum(m[cbind(result$x,result$y)] + 1)\r\n\r\n\r\n[1] 452\r\n\r\n— Part 2 —\r\nSet up a recursive function to check all the nearest neighbours, except the ones that have already been checked.\r\n\r\n\r\ncheck_matrix <- m==9\r\n\r\nrecurse_lowpoint <- function(x, y){\r\n    \r\n  if(check_matrix[x,y]) return(NULL)\r\n  check_matrix[x,y]<<-TRUE\r\n  \r\n  value <- m[x,y]\r\n  if(value == 9) return(NULL)\r\n  \r\n  flowpoints <- tibble(x = x, y = y, v = value)\r\n  if(x < nrow(m)) flowpoints <- bind_rows(flowpoints, recurse_lowpoint(x+1, y))\r\n  if(y < ncol(m)) flowpoints <- bind_rows(flowpoints, recurse_lowpoint(x, y+1))\r\n  if(x > 1) flowpoints <- bind_rows(flowpoints, recurse_lowpoint(x-1, y))\r\n  if(y > 1) flowpoints <- bind_rows(flowpoints, recurse_lowpoint(x, y-1))\r\n  \r\n  return(flowpoints)\r\n}\r\n\r\nflowpoints <- map2(result$x, result$y, recurse_lowpoint)\r\n\r\nflowpoints |> map_dbl(nrow) |> sort(decreasing = TRUE) |> head(3) |> prod()\r\n\r\n\r\n[1] 1263735\r\n\r\n\r\nDay 10\r\nhttps://adventofcode.com/2021/day/10\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 10, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-10-input.txt\")) |> \r\n  strsplit(\"\")\r\n\r\n\r\n\r\n— Part 1 —\r\nIn a loop, collected a queue of open-brackets and then check each closing bracket against the last item in the opening queue. If check fails, exit early with the failure.\r\n\r\n\r\nchecker <- function(v){\r\n  \r\n  v <- unlist(v)\r\n  \r\n  open_char <- c(\"{\",\"[\",\"(\",\"<\")\r\n  close_char <- c(\"}\", \"]\", \")\", \">\")\r\n  \r\n  mapping <- tibble(open = open_char,\r\n                    close = close_char) |> \r\n    deframe()\r\n  \r\n  queue <- c()\r\n  \r\n  for(i in v){\r\n    if(i %in% open_char) queue <- c(queue,i)\r\n    if(i %in% close_char) {\r\n      check_closing <- mapping[tail(queue,1)] == i\r\n      if(!check_closing) return(i)\r\n      queue <- head(queue,-1)\r\n    }\r\n  }\r\n  \r\n  return(\"OK\")\r\n}\r\n\r\nx <- map(input,checker) |> unlist()\r\n\r\nvalue_map <- tibble(\r\n  close_char = c(\"}\", \"]\", \")\", \">\"),\r\n  value = c(1197,57, 3, 25137)\r\n) |> \r\n  deframe()\r\n\r\nsum(value_map[x[x != \"OK\"]])\r\n\r\n\r\n[1] 311895\r\n\r\n— Part 2 —\r\nDid myself a massive favour here with my part one algo - already had a queue of opening brackets and the code to fetch the closing brackets, so just had to return the closing brackets for the queue.\r\n\r\n\r\np2 <- input[unlist(x)== \"OK\"]\r\n\r\ncompleter <- function(v){\r\n  \r\n  v <- unlist(v)\r\n  \r\n  open_char <- c(\"{\",\"[\",\"(\",\"<\")\r\n  close_char <- c(\"}\", \"]\", \")\", \">\")\r\n  \r\n  mapping <- tibble(open = open_char,\r\n                    close = close_char) |> \r\n    deframe()\r\n  \r\n  queue <- c()\r\n  \r\n  for(i in v){\r\n    if(i %in% open_char) queue <- c(queue,i)\r\n    if(i %in% close_char) {\r\n      check_closing <- mapping[tail(queue,1)] == i\r\n      if(!check_closing) return(i)\r\n      queue <- head(queue,-1)\r\n    }\r\n  }\r\n  \r\n  return(mapping[rev(queue)])\r\n  \r\n}\r\n\r\nx <- map(p2,completer)\r\n\r\nscorer <- function(x){\r\n  score <- 0\r\n  value_table <- tibble(\r\n    char = c(\"}\", \"]\", \")\", \">\"),\r\n    score = c(3,2,1,4)\r\n  ) |> \r\n    deframe()\r\n  \r\n  for(i in x){\r\n    \r\n    score <- score * 5\r\n    score <- score + value_table[i]\r\n  }\r\n  \r\n  return(score)\r\n}\r\n\r\n\r\nmap(x,scorer) |> unlist() |> median()\r\n\r\n\r\n[1] 2904180541\r\n\r\n\r\nDay 11\r\nhttps://adventofcode.com/2021/day/11\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 11, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-11-input.txt\")) |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric) |> \r\n  reduce(rbind)\r\n\r\nexample <- c(\"5483143223\",\r\n             \"2745854711\",\r\n             \"5264556173\",\r\n             \"6141336146\",\r\n             \"6357385478\",\r\n             \"4167524645\",\r\n             \"2176841721\",\r\n             \"6882881134\",\r\n             \"4846848554\",\r\n             \"5283751526\") |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric) |> \r\n  reduce(rbind)\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\nm <- input\r\n\r\nget_neighbours <- function(x_value,y_value){\r\n  i <- crossing(x = c(-1,0,1) + x_value, \r\n                y = c(-1,0,1) + y_value) |> \r\n    filter(between(x,1,10), \r\n           between(y,1,10),\r\n           !(x == x_value & y == y_value)\r\n           )\r\n  \r\n  return(i)\r\n}\r\n\r\nflash_counter <- numeric(100)\r\n\r\nfor(step in 1:100){\r\n  \r\n  m <- m + 1\r\n  completed_flashes <- tibble()\r\n  \r\n  while(any(m > 9)){\r\n    \r\n    flash_queue <- which(m > 9, arr.ind = TRUE) |> as_tibble()\r\n    colnames(flash_queue) <- c(\"y\",\"x\")\r\n    \r\n    completed_flashes <- bind_rows(completed_flashes, flash_queue)\r\n    \r\n    flash_effect <- map2_dfr(flash_queue$x,flash_queue$y, get_neighbours) |> \r\n      anti_join(completed_flashes, by = c(\"x\",\"y\")) |> \r\n      count(x,y)\r\n\r\n    m[cbind(flash_effect$y,flash_effect$x)] <- m[cbind(flash_effect$y,flash_effect$x)] + flash_effect$n    \r\n    \r\n    m[cbind(completed_flashes$y,completed_flashes$x)] <- 0\r\n  }\r\n  \r\n  flash_counter[step] <- nrow(completed_flashes)\r\n}\r\n\r\nsum(flash_counter)\r\n\r\n\r\n[1] 1681\r\n\r\n— Part 2 —\r\n\r\n\r\nm <- input\r\nflash_counter <- 1\r\n\r\nrepeat{\r\n  \r\n  m <- m + 1\r\n  completed_flashes <- tibble()\r\n  \r\n  while(any(m > 9)){\r\n    \r\n    flash_queue <- which(m > 9, arr.ind = TRUE) |> as_tibble()\r\n    colnames(flash_queue) <- c(\"y\",\"x\")\r\n    \r\n    completed_flashes <- bind_rows(completed_flashes, flash_queue)\r\n    \r\n    flash_effect <- map2_dfr(flash_queue$x,flash_queue$y, get_neighbours) |> \r\n      anti_join(completed_flashes, by = c(\"x\",\"y\")) |> \r\n      count(x,y)\r\n\r\n    m[cbind(flash_effect$y,flash_effect$x)] <- m[cbind(flash_effect$y,flash_effect$x)] + flash_effect$n    \r\n    \r\n    m[cbind(completed_flashes$y,completed_flashes$x)] <- 0\r\n  }\r\n  \r\n  if(all(m == 0)) break\r\n  \r\n  flash_counter <- flash_counter + 1\r\n}\r\n\r\nflash_counter\r\n\r\n\r\n[1] 276\r\n\r\n\r\nDay 12\r\nhttps://adventofcode.com/2021/day/12\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 12, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- tibble(x = readLines(here::here(\"2021/day-12-input.txt\"))) |> \r\n  separate(x,into = c(\"left\",\"right\"), sep = \"\\\\-\")\r\n\r\nexample <- c(\r\n  \"start-A\",\r\n  \"start-b\",\r\n  \"A-c\",\r\n  \"A-b\",\r\n  \"b-d\",\r\n  \"A-end\",\r\n  \"b-end\") %>%\r\n  tibble(x = .) |> \r\n  separate(x,into = c(\"left\",\"right\"), sep = \"\\\\-\")\r\n\r\nexample_two <- c(\r\n  \"dc-end\",\r\n\"HN-start\",\r\n\"start-kj\",\r\n\"dc-start\",\r\n\"dc-HN\",\r\n\"LN-dc\",\r\n\"HN-end\",\r\n\"kj-sa\",\r\n\"kj-HN\",\r\n\"kj-dc\"\r\n)%>%\r\n  tibble(x = .) |> \r\n  separate(x,into = c(\"left\",\"right\"), sep = \"\\\\-\")\r\n\r\nexample_three <- c(\r\n  \"fs-end\",\r\n\"he-DX\",\r\n\"fs-he\",\r\n\"start-DX\",\r\n\"pj-DX\",\r\n\"end-zg\",\r\n\"zg-sl\",\r\n\"zg-pj\",\r\n\"pj-he\",\r\n\"RW-he\",\r\n\"fs-DX\",\r\n\"pj-RW\",\r\n\"zg-RW\",\r\n\"start-pj\",\r\n\"he-WI\",\r\n\"zg-he\",\r\n\"pj-fs\",\r\n\"start-RW\"\r\n)%>%\r\n  tibble(x = .) |> \r\n  separate(x,into = c(\"left\",\"right\"), sep = \"\\\\-\")\r\n\r\n\r\n\r\n— Part 1 —\r\nCount all possible paths. Constraints: cannot visit small cave more than once. Must start at start and end and end.\r\nThis should be a function that takes in a node. Finds the child nodes For each child node, check to see if the child nodes are valid against: - have we been here before? - Are we allowed to go back? - Is this the end?\r\nFor the valid child nodes, call the function again (recursively)\r\nand return path on exit.\r\n\r\n\r\nconnections <- input\r\n\r\npaths <- connections |> \r\n  bind_rows(connections |> \r\n              select(left = right, right = left))\r\n\r\nn <- \"start\"\r\np <- \"\"\r\n\r\nvalid_child <- function(n,p){\r\n  \r\n  # if haven't been there, is ok\r\n  if(!n %in% p) return(TRUE) \r\n  # if is uppercase, ok to go back\r\n  if(toupper(n) == n) return(TRUE)\r\n  # if not uppercase and have been there, bad\r\n  return(FALSE)\r\n}\r\n\r\npathfinder <- function(n, current_path){\r\n  current_path <- c(current_path,n)\r\n  \r\n  if(n == \"end\") return(tibble(path = list(current_path)))\r\n  \r\n  child_nodes <- paths$right[paths$left == n]\r\n  \r\n  valid_child_nodes <- child_nodes[map_lgl(child_nodes,\r\n                                           valid_child, \r\n                                           current_path)]\r\n  \r\n  if(length(valid_child_nodes) == 0) return(NULL)\r\n  \r\n  # all_paths <- map(valid_child_nodes, pathfinder, current_path)\r\n  \r\n  all_paths <- tibble(path = list())\r\n  \r\n  for(cn in valid_child_nodes) {\r\n    all_paths <- bind_rows(all_paths,pathfinder(cn,current_path))\r\n  }\r\n  \r\n  return(all_paths)\r\n}\r\n\r\np1 <- pathfinder(n = \"start\", current_path = character())\r\np1\r\n\r\n\r\n\r\n\r\n[1] 5457\r\n\r\n— Part 2 —\r\n\r\n\r\nconnections <- input\r\n\r\npaths <- connections |> \r\n  bind_rows(connections |> \r\n              select(left = right, right = left))\r\n\r\nn <- \"start\"\r\np <- \"\"\r\n\r\nvalid_child <- function(n,p){\r\n  # no start!\r\n  if(n == \"start\") return(FALSE)\r\n  # if haven't been there, is ok\r\n  if(!n %in% p) return(TRUE)\r\n  # if is uppercase, ok to go back\r\n  if(identical(toupper(n),n)) return(TRUE)\r\n  # if not uppercase and have been there only once, ok \r\n  lower_p <- p[tolower(p)==p]\r\n  if(identical(lower_p,unique(lower_p))) return(TRUE)\r\n  # otherwise bad.\r\n  return(FALSE)\r\n}\r\n\r\npathfinder <- function(n, current_path){\r\n  current_path <- c(current_path,n)\r\n  \r\n  if(n == \"end\") return(tibble(path = list(current_path)))\r\n  \r\n  child_nodes <- paths$right[paths$left == n]\r\n  \r\n  valid_child_nodes <- child_nodes[map_lgl(child_nodes,\r\n                                           valid_child, \r\n                                           current_path)]\r\n  \r\n  if(length(valid_child_nodes) == 0) return(NULL)\r\n  \r\n  all_paths <- tibble(path = list())\r\n  \r\n  for(cn in valid_child_nodes) {\r\n    all_paths <- bind_rows(all_paths,pathfinder(cn,current_path))\r\n  }\r\n  \r\n  return(all_paths)\r\n}\r\n\r\np2 <- pathfinder(n = \"start\", current_path = character())\r\nnrow(p2)\r\n\r\n\r\n\r\n\r\n[1] 128506\r\n\r\n\r\nDay 13\r\nhttps://adventofcode.com/2021/day/13\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n  \r\n\r\n  ragg_png = function(..., res = 150) {\r\n    ragg::agg_png(..., res = res, units = \"in\")\r\n  }\r\n  knitr::opts_chunk$set(dev = \"ragg_png\")\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 13, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-13-input.txt\"))\r\n\r\ndots <- tibble(x = str_subset(input,\"fold\",negate = TRUE)) |> \r\n  filter(x != \"\") |> \r\n  separate(x, into = c(\"x\",\"y\"), sep = \",\", convert = TRUE)\r\n\r\nfolds <- tibble(x = str_subset(input,\"fold\")) |> \r\n  extract(x,into = c(\"axis\",\"index\"), regex = \"(x|y)\\\\=([0-9]+)\", convert = TRUE)\r\n\r\n\r\n\r\n— Part 1 —\r\nOriginal solution:\r\n\r\n\r\nfold_x <- function(d,index){\r\n  d <- d |> \r\n    mutate(x2 = index-x,\r\n           x = ifelse(x2 < 0, x2+index, x),\r\n           x2 = NULL\r\n           ) |> \r\n    distinct()\r\n  \r\n  return(d)\r\n}\r\n\r\nfold_y <- function(d,index){\r\n  \r\n  d <- d |> \r\n    mutate(y2 = index-y,\r\n           y = ifelse(y2 < 0, y2+index, y),\r\n           y2 = NULL) |> \r\n    distinct()\r\n  \r\n  return(d)\r\n}\r\n\r\nfold <- function(d,axis,index){\r\n  \r\n  switch(axis,\r\n         \"x\"=d <- fold_x(d,index),\r\n         \"y\"=d <- fold_y(d,index),\r\n         stop()\r\n         )\r\n  \r\n  return(d)\r\n}\r\n\r\np1 <- fold(dots,folds$axis[1],folds$index[1])\r\n\r\nnrow(p1)\r\n\r\n\r\n[1] 785\r\n\r\nSome conciseness cleanups:\r\n\r\n\r\nfold <- function(d,axis,index){\r\n  d$tmp <- index - d[[axis]]\r\n  d[[axis]] <- ifelse(d$tmp <0,d$tmp + index, d[[axis]])\r\n  d$tmp <- NULL\r\n  return(distinct(d))\r\n}\r\n\r\nfold(dots,folds$axis[1],folds$index[1]) |> nrow()\r\n\r\n\r\n[1] 785\r\n\r\n— Part 2 —\r\nFor lack of a better solution, may as well just plot the silly thing?\r\n\r\n\r\nfold_all <- reduce2(folds$axis,folds$index,fold, .init = dots)\r\n\r\nggplot(fold_all, aes(x = x, y = y)) + \r\n  geom_point() + \r\n  scale_y_reverse() + \r\n  coord_fixed() + \r\n  tantastic::theme_tantastic() + \r\n  theme(\r\n    axis.title.x = element_blank(),\r\n    axis.title.y = element_blank(),\r\n    axis.text.x = element_blank(),\r\n    axis.text.y = element_blank()\r\n  ) + \r\n  labs(\r\n    title = \"Transparent Origami\",\r\n    subtitle = \"Advent of Code, 2021 Day 13\",\r\n    caption = \"@_TanHo\"\r\n  )\r\n\r\n\r\n\r\n\r\n\r\nDay 14\r\nhttps://adventofcode.com/2021/day/14\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 14, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-14-input.txt\"))\r\n\r\npolymer <- input[1]\r\n\r\nsubs <- tibble(x = input[-c(1:2)]) |> \r\n  separate(x, into = c(\"match\",\"insert\"),\" -> \")\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\ncheck_substitution <- \\(search,polymer){\r\n  \r\n  p1 <- polymer |> strsplit(\"\") |> unlist()\r\n  p <- paste0(p1,lead(p1,default = \"1\"))\r\n  \r\n  return(which(p == search))\r\n}\r\n\r\ninsert_subs <- \\(polymer, insert_char, start_loc){\r\n  end_loc <- start_loc + 1\r\n  \r\n  paste0(substr(polymer,1,start_loc),insert_char,substr(polymer,end_loc,str_length(polymer)))\r\n}\r\n\r\npolymer_substitution <- function(polymer,step){\r\n  \r\n  cat(step, sep = \"\\n\")\r\n  \r\n  x <- subs |> \r\n    mutate(\r\n      start = map(match,check_substitution,polymer)\r\n    ) |> \r\n    unnest(start) |> \r\n    arrange(start) |> \r\n    mutate(\r\n      start = start + row_number() -1\r\n    )\r\n  \r\n  reduce2(x$insert,x$start,insert_subs,.init = polymer)\r\n}\r\n\r\nx <- reduce(1:10,polymer_substitution,.init = polymer)\r\n\r\ny <- tibble(char = x |> strsplit(\"\") |> unlist()) |> \r\n  count(char) |> \r\n  pull(n) |> \r\n  range() |> \r\n  diff()\r\n\r\n\r\n\r\n\r\n[1] 3906\r\n\r\n— Part 2 —\r\nMind blanked today on the not-naive solution to growing a vector - took me until the 90 minute mark to start looking for better algorithms and I ended up needing reddit’s assistance to think of storing a count of each pair. This was not one of my more brilliant nights.\r\n\r\n\r\ndictionary_count <- subs |> \r\n  mutate(\r\n    n = str_count(polymer,match)\r\n  )\r\n\r\njoin_dictionary <- subs |> \r\n  mutate(\r\n    left = paste0(str_sub(match,1,1),insert),\r\n    right = paste0(insert,str_sub(match,2,2))\r\n  ) |> \r\n  pivot_longer(c(\"left\",\"right\")) |> \r\n  select(match,value)\r\n\r\ndo_polymer <- function(counts, step){\r\n  \r\n  x <- counts |> \r\n    full_join(join_dictionary, by = \"match\") |> \r\n    group_by(match = value) |> \r\n    summarise(\r\n      n = sum(n, na.rm = TRUE)\r\n    )\r\n  \r\n  return(x)\r\n}\r\n\r\npairs <- reduce(1:40,do_polymer,.init = dictionary_count)\r\n\r\npairs |> \r\n  mutate(letters = strsplit(match,\"\")) |> \r\n  unnest_longer(letters) |> \r\n  group_by(letters) |> \r\n  summarise(n = sum(n, na.rm = TRUE)) |> \r\n  ungroup() |> \r\n  mutate(\r\n    n = case_when(\r\n      letters == str_sub(polymer,1,1) ~ n+1,\r\n      letters == str_sub(polymer,-1,-1) ~ n+1,\r\n      TRUE ~ as.numeric(n)),\r\n    n = n/2)  |> \r\n  pull(n) |> \r\n  range() |> \r\n  diff()\r\n\r\n\r\n\r\n\r\n[1] 4441317262452\r\n\r\n\r\nDay 15\r\nhttps://adventofcode.com/2021/day/15\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 15, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-15-input.txt\")) |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric) |> \r\n  reduce(rbind)\r\n\r\nexample <- c(\"1163751742\",\r\n           \"1381373672\",\r\n           \"2136511328\",\r\n           \"3694931569\",\r\n           \"7463417111\",\r\n           \"1319128137\",\r\n           \"1359912421\",\r\n           \"3125421639\",\r\n           \"1293138521\",\r\n           \"2311944581\") |> \r\n  strsplit(\"\") |> \r\n  map(as.numeric) |> \r\n  reduce(rbind)\r\n\r\n\r\n\r\n— Part 1 —\r\n\r\n\r\n# give me all available up/down/left/right steps that are on the grid\r\n\r\nm <- input\r\n\r\nget_neighbours <- function(row_loc, col_loc, queue){\r\n  \r\n  n <- tibble(row = c(-1,1,0,0), col = c(0,0,1,-1)) |> \r\n    mutate(\r\n      row = row + row_loc,\r\n      col = col + col_loc\r\n    ) |> \r\n    filter(row <= nrow(m), \r\n           col <= nrow(m), \r\n           row >= 1, \r\n           col >= 1) |> \r\n    inner_join(queue, by = c(\"row\",\"col\"))\r\n  \r\n  return(n)\r\n}\r\n  \r\n  # populate distance matrix of equal size to m\r\n  distances <- matrix(Inf,nrow = nrow(m),ncol = ncol(m))\r\n  \r\n  # set origin as top left hand corner\r\n  distances[1] <- 0\r\n  \r\n  # create queue of indices to check\r\n  queue <- crossing(row = 1:nrow(m), col = 1:ncol(m))\r\n  \r\n  # create copy of queue that will list the shortest path from source.\r\n  prev <- queue |> \r\n    mutate(prev = 0)\r\n  \r\n  counter <- 0\r\n  \r\n  while(nrow(queue) > 0){\r\n    \r\n    counter <- counter + 1\r\n    \r\n    queue <- queue |> \r\n      mutate(dist = distances[cbind(row,col)])\r\n    \r\n    i <- queue |> slice_min(dist,with_ties = FALSE,n = 1)\r\n    \r\n    queue <- queue |> anti_join(i, by = c(\"row\",\"col\"))\r\n    \r\n    neighbours <- get_neighbours(i$row, i$col, queue)\r\n    \r\n    if(nrow(neighbours) == 0) next\r\n    \r\n    for(n in seq_len(nrow(neighbours))){\r\n      \r\n      possible_dist <- i$dist + m[neighbours$row[n],neighbours$col[n]]\r\n      \r\n      if(possible_dist < distances[neighbours$row[n],neighbours$col[n]]){\r\n        distances[neighbours$row[n],neighbours$col[n]] <- possible_dist\r\n        prev$prev[prev$row == neighbours$row[n] & prev$col == neighbours$col[n]] <- counter\r\n      }\r\n      \r\n    }\r\n    \r\n  }\r\n\r\n  distances[nrow(m),ncol(m)]\r\n\r\n\r\n\r\n\r\n[1] 523\r\n\r\n— Part 2 —\r\nRan into a bunch of problems and ended up leaving on overnight after attempting some optimizations.\r\nBuild out incremented matrix.\r\n\r\n\r\nm <- input\r\n\r\ncol_1 <- map(0:4,~ifelse(m + .x > 9,m + .x - 9, m + .x)) |> reduce(rbind)\r\ncol_2 <- map(1:5,~ifelse(m + .x > 9,m + .x - 9, m + .x)) |> reduce(rbind)\r\ncol_3 <- map(2:6,~ifelse(m + .x > 9,m + .x - 9, m + .x)) |> reduce(rbind)\r\ncol_4 <- map(3:7,~ifelse(m + .x > 9,m + .x - 9, m + .x)) |> reduce(rbind)\r\ncol_5 <- map(4:8,~ifelse(m + .x > 9,m + .x - 9, m + .x)) |> reduce(rbind)\r\n\r\nm <- cbind(col_1,col_2,col_3,col_4,col_5)\r\n\r\n\r\n\r\nbuild out a list structure of neighbours rather than calculating at each step\r\n\r\n\r\nneighbours_matrix <- crossing(row = seq_len(nrow(m)),\r\n                              col = seq_len(ncol(m))) |> \r\n  arrange(col,row) |> \r\n  mutate(index = row_number(),\r\n         add = list(tibble(rp = c(-1,1,0,0), cp = c(0,0,1,-1)))\r\n  ) |> \r\n  unnest(add) |> \r\n  mutate(row2 = row + rp,\r\n         col2 = col + cp) |> \r\n  filter(row2 <= nrow(m),\r\n         col2 <= ncol(m),\r\n         row2 >=1,\r\n         col2 >=1) |> \r\n  select(-rp,-cp) %>%\r\n  left_join(.,.,by = c(\"row2\"=\"row\",\"col2\"=\"col\")) |> \r\n  select(index = index.x, neighbour = index.y) |> \r\n  distinct() |> \r\n  group_by(index) |> \r\n  summarise(neighbour = list(neighbour)) |> \r\n  deframe()\r\n\r\nhead(neighbours_matrix)\r\n\r\n\r\n$`1`\r\n[1]   2 501\r\n\r\n$`2`\r\n[1]   1   3 502\r\n\r\n$`3`\r\n[1]   2   4 503\r\n\r\n$`4`\r\n[1]   3   5 504\r\n\r\n$`5`\r\n[1]   4   6 505\r\n\r\n$`6`\r\n[1]   5   7 506\r\n\r\n\r\n$`1`\r\n[1]   2 501\r\n\r\n$`2`\r\n[1]   1   3 502\r\n\r\n$`3`\r\n[1]   2   4 503\r\n\r\n$`4`\r\n[1]   3   5 504\r\n\r\n$`5`\r\n[1]   4   6 505\r\n\r\n$`6`\r\n[1]   5   7 506\r\n\r\nrun dijkstra’s algo (?) oddly slow.\r\n\r\n\r\n  distances <- matrix(Inf,nrow = nrow(m),ncol = ncol(m))\r\n  \r\n  # set origin as top left hand corner\r\n  distances[1] <- 0\r\n  \r\n  # create queue of indices to check\r\n  queue <- seq_along(m) |> as.list()\r\n  \r\n  counter <- 0\r\n  \r\n  while(length(queue) > 0){\r\n    \r\n    counter <- counter + 1\r\n    \r\n    if(counter %% 1000 == 0) cat(counter, format(Sys.time()), \"\\n\")\r\n    \r\n    i <- queue[which.min(distances[queue])] # slow?\r\n    \r\n    queue <- queue[queue!=i] #slow?\r\n    \r\n    neighbours <- neighbours_matrix[[as.character(i)]]\r\n    neighbours <- neighbours[neighbours %in% queue] # slow?\r\n    \r\n    for(n in neighbours){\r\n      \r\n      possible_dist <- distances[i] + m[n] \r\n      \r\n      if(possible_dist < distances[n]) distances[n] <- possible_dist\r\n    }\r\n  }\r\n\r\n  distances[nrow(m),ncol(m)]\r\n\r\n\r\n\r\n\r\n[1] 2876\r\n\r\n— Optimizing —\r\nOptimizing. Biggest culprits so far:\r\nneighbours %in% queue scans 250K vector for ~1-4 objects, much better is a visited matrix to lookup by position. net gain: 45 minutes -> 6 minutes (screaming internally.)\r\nqueue <- queue != i should be next?\r\n\r\n\r\n# populate distance matrix of equal size to m\r\n  distances <- matrix(Inf,nrow = nrow(m),ncol = ncol(m))\r\n  \r\n  # set origin as top left hand corner\r\n  distances[1] <- 0\r\n  \r\n  # create queue of indices to check\r\n  queue <- seq_along(m)\r\n  visited <- matrix(F,nrow = nrow(m), ncol = ncol(m))\r\n  counter <- 0\r\n  \r\n  while(!visited[nrow(m),ncol(m)]){\r\n    \r\n    counter <- counter + 1\r\n    \r\n    if(counter %% 1000 == 0) cat(counter, format(Sys.time()), \"\\n\")\r\n    \r\n    i <- queue[which.min(distances[queue])] # slow?\r\n    queue <- queue[queue!=i] #slow?\r\n    visited[i] <- TRUE\r\n    \r\n    neighbours <- neighbours_matrix[i] |> unlist()\r\n    neighbours <- neighbours[!visited[neighbours]]\r\n    \r\n    for(n in neighbours){\r\n      \r\n      possible_dist <- distances[i] + m[n]\r\n      if(possible_dist < distances[n]) distances[n] <- possible_dist\r\n    }\r\n  }\r\n\r\n\r\n1000 2021-12-17 13:07:24 \r\n2000 2021-12-17 13:07:29 \r\n3000 2021-12-17 13:07:35 \r\n4000 2021-12-17 13:07:40 \r\n5000 2021-12-17 13:07:45 \r\n6000 2021-12-17 13:07:51 \r\n7000 2021-12-17 13:07:57 \r\n8000 2021-12-17 13:08:02 \r\n9000 2021-12-17 13:08:08 \r\n10000 2021-12-17 13:08:10 \r\n11000 2021-12-17 13:08:12 \r\n12000 2021-12-17 13:08:14 \r\n13000 2021-12-17 13:08:16 \r\n14000 2021-12-17 13:08:18 \r\n15000 2021-12-17 13:08:20 \r\n16000 2021-12-17 13:08:22 \r\n17000 2021-12-17 13:08:24 \r\n18000 2021-12-17 13:08:27 \r\n19000 2021-12-17 13:08:29 \r\n20000 2021-12-17 13:08:31 \r\n21000 2021-12-17 13:08:33 \r\n22000 2021-12-17 13:08:35 \r\n23000 2021-12-17 13:08:37 \r\n24000 2021-12-17 13:08:39 \r\n25000 2021-12-17 13:08:41 \r\n26000 2021-12-17 13:08:43 \r\n27000 2021-12-17 13:08:45 \r\n28000 2021-12-17 13:08:47 \r\n29000 2021-12-17 13:08:49 \r\n30000 2021-12-17 13:08:51 \r\n31000 2021-12-17 13:08:53 \r\n32000 2021-12-17 13:08:55 \r\n33000 2021-12-17 13:08:57 \r\n34000 2021-12-17 13:08:59 \r\n35000 2021-12-17 13:09:01 \r\n36000 2021-12-17 13:09:03 \r\n37000 2021-12-17 13:09:05 \r\n38000 2021-12-17 13:09:07 \r\n39000 2021-12-17 13:09:09 \r\n40000 2021-12-17 13:09:11 \r\n41000 2021-12-17 13:09:13 \r\n42000 2021-12-17 13:09:15 \r\n43000 2021-12-17 13:09:16 \r\n44000 2021-12-17 13:09:18 \r\n45000 2021-12-17 13:09:20 \r\n46000 2021-12-17 13:09:22 \r\n47000 2021-12-17 13:09:24 \r\n48000 2021-12-17 13:09:25 \r\n49000 2021-12-17 13:09:27 \r\n50000 2021-12-17 13:09:29 \r\n51000 2021-12-17 13:09:31 \r\n52000 2021-12-17 13:09:32 \r\n53000 2021-12-17 13:09:34 \r\n54000 2021-12-17 13:09:36 \r\n55000 2021-12-17 13:09:38 \r\n56000 2021-12-17 13:09:39 \r\n57000 2021-12-17 13:09:41 \r\n58000 2021-12-17 13:09:43 \r\n59000 2021-12-17 13:09:45 \r\n60000 2021-12-17 13:09:46 \r\n61000 2021-12-17 13:09:48 \r\n62000 2021-12-17 13:09:50 \r\n63000 2021-12-17 13:09:51 \r\n64000 2021-12-17 13:09:53 \r\n65000 2021-12-17 13:09:55 \r\n66000 2021-12-17 13:09:56 \r\n67000 2021-12-17 13:09:58 \r\n68000 2021-12-17 13:10:00 \r\n69000 2021-12-17 13:10:01 \r\n70000 2021-12-17 13:10:03 \r\n71000 2021-12-17 13:10:04 \r\n72000 2021-12-17 13:10:06 \r\n73000 2021-12-17 13:10:08 \r\n74000 2021-12-17 13:10:09 \r\n75000 2021-12-17 13:10:11 \r\n76000 2021-12-17 13:10:13 \r\n77000 2021-12-17 13:10:14 \r\n78000 2021-12-17 13:10:16 \r\n79000 2021-12-17 13:10:17 \r\n80000 2021-12-17 13:10:19 \r\n81000 2021-12-17 13:10:20 \r\n82000 2021-12-17 13:10:22 \r\n83000 2021-12-17 13:10:23 \r\n84000 2021-12-17 13:10:25 \r\n85000 2021-12-17 13:10:26 \r\n86000 2021-12-17 13:10:28 \r\n87000 2021-12-17 13:10:29 \r\n88000 2021-12-17 13:10:30 \r\n89000 2021-12-17 13:10:32 \r\n90000 2021-12-17 13:10:33 \r\n91000 2021-12-17 13:10:35 \r\n92000 2021-12-17 13:10:36 \r\n93000 2021-12-17 13:10:38 \r\n94000 2021-12-17 13:10:39 \r\n95000 2021-12-17 13:10:40 \r\n96000 2021-12-17 13:10:42 \r\n97000 2021-12-17 13:10:43 \r\n98000 2021-12-17 13:10:45 \r\n99000 2021-12-17 13:10:46 \r\n100000 2021-12-17 13:10:48 \r\n101000 2021-12-17 13:10:49 \r\n102000 2021-12-17 13:10:50 \r\n103000 2021-12-17 13:10:52 \r\n104000 2021-12-17 13:10:53 \r\n105000 2021-12-17 13:10:54 \r\n106000 2021-12-17 13:10:55 \r\n107000 2021-12-17 13:10:57 \r\n108000 2021-12-17 13:10:58 \r\n109000 2021-12-17 13:10:59 \r\n110000 2021-12-17 13:11:00 \r\n111000 2021-12-17 13:11:02 \r\n112000 2021-12-17 13:11:03 \r\n113000 2021-12-17 13:11:04 \r\n114000 2021-12-17 13:11:05 \r\n115000 2021-12-17 13:11:07 \r\n116000 2021-12-17 13:11:08 \r\n117000 2021-12-17 13:11:09 \r\n118000 2021-12-17 13:11:10 \r\n119000 2021-12-17 13:11:11 \r\n120000 2021-12-17 13:11:13 \r\n121000 2021-12-17 13:11:14 \r\n122000 2021-12-17 13:11:15 \r\n123000 2021-12-17 13:11:16 \r\n124000 2021-12-17 13:11:17 \r\n125000 2021-12-17 13:11:18 \r\n126000 2021-12-17 13:11:19 \r\n127000 2021-12-17 13:11:21 \r\n128000 2021-12-17 13:11:22 \r\n129000 2021-12-17 13:11:23 \r\n130000 2021-12-17 13:11:24 \r\n131000 2021-12-17 13:11:25 \r\n132000 2021-12-17 13:11:26 \r\n133000 2021-12-17 13:11:27 \r\n134000 2021-12-17 13:11:28 \r\n135000 2021-12-17 13:11:29 \r\n136000 2021-12-17 13:11:30 \r\n137000 2021-12-17 13:11:31 \r\n138000 2021-12-17 13:11:32 \r\n139000 2021-12-17 13:11:33 \r\n140000 2021-12-17 13:11:34 \r\n141000 2021-12-17 13:11:35 \r\n142000 2021-12-17 13:11:36 \r\n143000 2021-12-17 13:11:37 \r\n144000 2021-12-17 13:11:38 \r\n145000 2021-12-17 13:11:39 \r\n146000 2021-12-17 13:11:40 \r\n147000 2021-12-17 13:11:41 \r\n148000 2021-12-17 13:11:42 \r\n149000 2021-12-17 13:11:43 \r\n150000 2021-12-17 13:11:44 \r\n151000 2021-12-17 13:11:44 \r\n152000 2021-12-17 13:11:45 \r\n153000 2021-12-17 13:11:46 \r\n154000 2021-12-17 13:11:47 \r\n155000 2021-12-17 13:11:48 \r\n156000 2021-12-17 13:11:49 \r\n157000 2021-12-17 13:11:50 \r\n158000 2021-12-17 13:11:51 \r\n159000 2021-12-17 13:11:51 \r\n160000 2021-12-17 13:11:52 \r\n161000 2021-12-17 13:11:53 \r\n162000 2021-12-17 13:11:54 \r\n163000 2021-12-17 13:11:55 \r\n164000 2021-12-17 13:11:55 \r\n165000 2021-12-17 13:11:56 \r\n166000 2021-12-17 13:11:57 \r\n167000 2021-12-17 13:11:57 \r\n168000 2021-12-17 13:11:58 \r\n169000 2021-12-17 13:11:59 \r\n170000 2021-12-17 13:12:00 \r\n171000 2021-12-17 13:12:00 \r\n172000 2021-12-17 13:12:01 \r\n173000 2021-12-17 13:12:02 \r\n174000 2021-12-17 13:12:02 \r\n175000 2021-12-17 13:12:03 \r\n176000 2021-12-17 13:12:04 \r\n177000 2021-12-17 13:12:04 \r\n178000 2021-12-17 13:12:05 \r\n179000 2021-12-17 13:12:05 \r\n180000 2021-12-17 13:12:06 \r\n181000 2021-12-17 13:12:07 \r\n182000 2021-12-17 13:12:07 \r\n183000 2021-12-17 13:12:08 \r\n184000 2021-12-17 13:12:08 \r\n185000 2021-12-17 13:12:09 \r\n186000 2021-12-17 13:12:09 \r\n187000 2021-12-17 13:12:10 \r\n188000 2021-12-17 13:12:11 \r\n189000 2021-12-17 13:12:11 \r\n190000 2021-12-17 13:12:12 \r\n191000 2021-12-17 13:12:12 \r\n192000 2021-12-17 13:12:13 \r\n193000 2021-12-17 13:12:13 \r\n194000 2021-12-17 13:12:14 \r\n195000 2021-12-17 13:12:14 \r\n196000 2021-12-17 13:12:15 \r\n197000 2021-12-17 13:12:15 \r\n198000 2021-12-17 13:12:15 \r\n199000 2021-12-17 13:12:16 \r\n200000 2021-12-17 13:12:16 \r\n201000 2021-12-17 13:12:17 \r\n202000 2021-12-17 13:12:17 \r\n203000 2021-12-17 13:12:18 \r\n204000 2021-12-17 13:12:18 \r\n205000 2021-12-17 13:12:19 \r\n206000 2021-12-17 13:12:19 \r\n207000 2021-12-17 13:12:19 \r\n208000 2021-12-17 13:12:20 \r\n209000 2021-12-17 13:12:20 \r\n210000 2021-12-17 13:12:20 \r\n211000 2021-12-17 13:12:21 \r\n212000 2021-12-17 13:12:21 \r\n213000 2021-12-17 13:12:21 \r\n214000 2021-12-17 13:12:22 \r\n215000 2021-12-17 13:12:22 \r\n216000 2021-12-17 13:12:22 \r\n217000 2021-12-17 13:12:22 \r\n218000 2021-12-17 13:12:23 \r\n219000 2021-12-17 13:12:23 \r\n220000 2021-12-17 13:12:23 \r\n221000 2021-12-17 13:12:24 \r\n222000 2021-12-17 13:12:24 \r\n223000 2021-12-17 13:12:24 \r\n224000 2021-12-17 13:12:24 \r\n225000 2021-12-17 13:12:25 \r\n226000 2021-12-17 13:12:25 \r\n227000 2021-12-17 13:12:25 \r\n228000 2021-12-17 13:12:25 \r\n229000 2021-12-17 13:12:25 \r\n230000 2021-12-17 13:12:26 \r\n231000 2021-12-17 13:12:26 \r\n232000 2021-12-17 13:12:26 \r\n233000 2021-12-17 13:12:26 \r\n234000 2021-12-17 13:12:26 \r\n235000 2021-12-17 13:12:26 \r\n236000 2021-12-17 13:12:26 \r\n237000 2021-12-17 13:12:27 \r\n238000 2021-12-17 13:12:27 \r\n239000 2021-12-17 13:12:27 \r\n240000 2021-12-17 13:12:27 \r\n241000 2021-12-17 13:12:27 \r\n242000 2021-12-17 13:12:27 \r\n243000 2021-12-17 13:12:27 \r\n244000 2021-12-17 13:12:27 \r\n245000 2021-12-17 13:12:27 \r\n246000 2021-12-17 13:12:27 \r\n247000 2021-12-17 13:12:27 \r\n248000 2021-12-17 13:12:27 \r\n249000 2021-12-17 13:12:27 \r\n\r\n  distances[nrow(m),ncol(m)]\r\n\r\n\r\n[1] 2876\r\n\r\n\r\nDay 16\r\nhttps://adventofcode.com/2021/day/16\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(R.utils)\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 16, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\ninput <- readLines(here::here(\"2021/day-16-input.txt\"))\r\n\r\n\r\n\r\n— Part 1 —\r\nHelper functions for converting:\r\n\r\n\r\n.hexbin <- tibble::tribble(\r\n  ~hex, ~bin,\r\n  \"0\", \"0000\",\r\n   \"1\",  \"0001\",\r\n   \"2\",  \"0010\",\r\n   \"3\",  \"0011\",\r\n   \"4\",  \"0100\",\r\n   \"5\",  \"0101\",\r\n   \"6\",  \"0110\",\r\n   \"7\",  \"0111\",\r\n   \"8\",  \"1000\",\r\n   \"9\",  \"1001\",\r\n   \"A\",  \"1010\",\r\n   \"B\",  \"1011\",\r\n   \"C\",  \"1100\",\r\n   \"D\",  \"1101\",\r\n   \"E\",  \"1110\",\r\n   \"F\",  \"1111\"\r\n  ) |> \r\n  deframe()\r\nhex2bin <- function(hex){\r\n  s <- strsplit(hex,\"\") |> unlist()\r\n  \r\n  paste(.hexbin[s],collapse = \"\")\r\n}\r\n\r\nbin2int <- function(bin){\r\n  # strtoi(bin,base = 2) # no good, overflows after 2^31\r\n  x <- as.numeric(strsplit(bin, \"\")[[1]])\r\n  sum(x * 2^rev((seq_along(x)-1)))\r\n}\r\n\r\n\r\n\r\nfurious notes as I try to understand stuff\r\nIdentify packets.\r\nFunction to parse:\r\nfirst three characters of the binary string are the version number\r\nnext three characters of binary identify type ID which controls how the rest of the string is parsed\r\nif:\r\ntype id = 4 => literal binary value\r\ntype id != 4 => operator, also passes in the subpackets.\r\nfunctions - read packet version - read packet type - do operation for packet type\r\nSome helpers.\r\n\r\n\r\nread_packet_version <- function(packet){\r\n  substr(packet,1,3) |> bin2int()\r\n}\r\n\r\nread_packet_type <- function(packet){\r\n  substr(packet,1,3) |> bin2int()\r\n}\r\n\r\nread_packet_length_type <- function(packet){\r\n  substr(packet,1,1) |> bin2int()\r\n}\r\n\r\nread_subpacket_bits <- function(packet){\r\n  substr(packet,1,15) |> bin2int()\r\n}\r\n\r\nread_subpacket_length <- function(packet){\r\n  substr(packet,1,11) |> bin2int()\r\n}\r\n\r\nread_literal_packet <- function(packet){\r\n  \r\n  x <- tibble(x = strsplit(packet,\"\") |> unlist()) |> \r\n    mutate(\r\n      n = row_number() %/% 5.00001 + 1\r\n    ) |> \r\n    group_by(n) |> \r\n    mutate(\r\n      h = first(x) |> as.numeric(),\r\n      x = ifelse(row_number() == 1,\"\",x)\r\n    ) |> \r\n    group_by(n,h) |> \r\n    summarise(x = paste0(x, collapse = \"\")) |> \r\n    ungroup() |> \r\n    mutate(\r\n      cumsum_h = cumsum(h==0),\r\n      keep = lag(cumsum_h,default = 0) == 0\r\n    ) |> \r\n    filter(keep)\r\n    \r\n  unprocessed <- str_sub(packet,max(x$n)*5+1)\r\n  \r\n  if(str_length(unprocessed) < 11) unprocessed <- \"\"\r\n  \r\n  literal_value <- x |> \r\n    pull(x) |> \r\n    paste(collapse = \"\") |> \r\n    bin2int()\r\n  \r\n  if(is.na(literal_value)) browser()\r\n  \r\n  return(list(value = literal_value, unprocessed = unprocessed))\r\n}\r\n\r\n\r\n\r\n\r\n\r\nread_packet <- function(packet){\r\n  packet_version <- read_packet_version(packet)\r\n  packet <- str_sub(packet,4)\r\n  packet_type <- read_packet_type(packet)\r\n  packet <- str_sub(packet,4)\r\n  \r\n  ## LITERAL PACKETS (Type 4)\r\n  if(packet_type == 4){\r\n    # return(packet_version)\r\n    literal <- read_literal_packet(packet)\r\n    # For Part One\r\n    return(\r\n      list(version = packet_version,\r\n           type = packet_type,\r\n           value = literal$value,\r\n           unprocessed = literal$unprocessed)\r\n    )\r\n  }\r\n  \r\n  packet_versions <- c(packet_version)\r\n  packet_types <- c(packet_type)\r\n  packet_values <- c()\r\n  # SUBPACKETS \r\n  ## SUBPACKETS WITH A LENGTH CONSTRAINT\r\n  length_type <- read_packet_length_type(packet)\r\n  packet <- str_sub(packet,2)\r\n  if(length_type == 0) {\r\n    subpacket_bits <- read_subpacket_bits(packet)\r\n    packet <- str_sub(packet,16)\r\n    subpacket <- str_sub(packet,1,subpacket_bits)\r\n    packet <- str_sub(packet,subpacket_bits+1)\r\n    while(str_length(subpacket) > 10){\r\n      returned_subpacket <- read_packet(subpacket)\r\n      packet_versions <- c(packet_versions, returned_subpacket$version)\r\n      packet_types <- c(packet_types, returned_subpacket$type)\r\n      packet_values <- c(packet_values, returned_subpacket$value)\r\n      subpacket <- returned_subpacket$unprocessed\r\n    }\r\n  }\r\n  \r\n  ## SUBPACKETS WITH A COUNT CONSTRAINT\r\n  if(length_type == 1){\r\n    subpacket_length <- read_subpacket_length(packet)\r\n    packet <- str_sub(packet,12)\r\n    for(i in seq_len(subpacket_length)){\r\n      returned_subpacket <- read_packet(packet)\r\n      packet_versions <- c(packet_versions, returned_subpacket$version)\r\n      packet_types <- c(packet_types, returned_subpacket$type)\r\n      packet_values <- c(packet_values,returned_subpacket$value)\r\n      packet <- returned_subpacket$unprocessed\r\n    }\r\n  }\r\n  \r\n  return(list(version = packet_versions,\r\n              type = packet_types,\r\n              value = packet_values,\r\n              unprocessed = packet))\r\n}\r\n\r\ndecode_packet <- function(hex){\r\n  hex2bin(hex) |> read_packet()\r\n}\r\n\r\n\r\n\r\nTests:\r\n\r\n\r\n.e1 <- decode_packet(\"D2FE28\")\r\ntestthat::expect_equal(.e1$version |> sum(), 6)\r\n.e2 <- decode_packet(\"8A004A801A8002F478\")\r\ntestthat::expect_equal(.e2$version |> sum(), 16)\r\n.e3 <- decode_packet(\"38006F45291200\")\r\ntestthat::expect_equal(.e3$version |> sum(),9)\r\n.e4 <- decode_packet(\"620080001611562C8802118E34\")\r\ntestthat::expect_equal(.e4$version |> sum(),12)\r\n.e5 <- decode_packet(\"C0015000016115A2E0802F182340\")\r\ntestthat::expect_equal(.e5$version |> sum(),23)\r\n.e6 <- decode_packet(\"A0016C880162017C3686B18A3D4780\")\r\ntestthat::expect_equal(.e6$version |> sum(),31)\r\n\r\n\r\n\r\n\r\n\r\np1 <- decode_packet(input)\r\nsum(p1$version)\r\n\r\n\r\n[1] 913\r\n\r\n— Part 2 —\r\nEditing so that I return a tree instead of a collapsed vector:\r\n\r\n\r\nread_packet <- function(packet){\r\n  packet_version <- read_packet_version(packet)\r\n  packet <- str_sub(packet,4)\r\n  packet_type <- read_packet_type(packet)\r\n  packet <- str_sub(packet,4)\r\n  \r\n  ## LITERAL PACKETS (Type 4)\r\n  if(packet_type == 4){\r\n    literal <- read_literal_packet(packet)\r\n    return(\r\n      list(version = packet_version,\r\n           type = packet_type,\r\n           value = literal$value,\r\n           unprocessed = literal$unprocessed)\r\n    )\r\n  }\r\n  subpackets <- list()\r\n  # SUBPACKETS \r\n  ## SUBPACKETS WITH A LENGTH CONSTRAINT\r\n  length_type <- read_packet_length_type(packet)\r\n  packet <- str_sub(packet,2)\r\n  if(length_type == 0) {\r\n    subpacket_bits <- read_subpacket_bits(packet)\r\n    packet <- str_sub(packet,16)\r\n    subpacket <- str_sub(packet,1,subpacket_bits)\r\n    packet <- str_sub(packet,subpacket_bits+1)\r\n    while(str_length(subpacket) > 10){\r\n      returned_subpacket <- read_packet(subpacket)\r\n      subpackets <- c(subpackets, list(returned_subpacket))\r\n      subpacket <- returned_subpacket$unprocessed\r\n    }\r\n  }\r\n  \r\n  ## SUBPACKETS WITH A COUNT CONSTRAINT\r\n  if(length_type == 1){\r\n    subpacket_length <- read_subpacket_length(packet)\r\n    packet <- str_sub(packet,12)\r\n    for(i in seq_len(subpacket_length)){\r\n      returned_subpacket <- read_packet(packet)\r\n      subpackets <- c(subpackets, list(returned_subpacket))\r\n      packet <- returned_subpacket$unprocessed\r\n    }\r\n  }\r\n  \r\n  return(list(\r\n    version = packet_version, \r\n    type = packet_type,\r\n    packets = subpackets,\r\n    unprocessed = packet))\r\n}\r\n\r\n\r\n\r\nRecursing over my tree:\r\n\r\n\r\nevaluate_packet <- function(packet){\r\n  packet_type <- packet |> pluck(\"type\")\r\n  if(packet_type == 4) return(packet$value)\r\n  \r\n  subpacket_values <- c()\r\n  \r\n  for(i in seq_along(packet$packets)){\r\n    subpacket_values <- c(subpacket_values, evaluate_packet(packet$packets[[i]]))\r\n  }\r\n  \r\n  packet_value <- switch(\r\n    as.character(packet_type),\r\n    \"0\" = sum(subpacket_values, na.rm = TRUE),\r\n    \"1\" = prod(subpacket_values, na.rm = TRUE),\r\n    \"2\" = min(subpacket_values, na.rm = TRUE),\r\n    \"3\" = max(subpacket_values, na.rm = TRUE),\r\n    \"5\" = as.numeric(subpacket_values[1] > subpacket_values[2]),\r\n    \"6\" = as.numeric(subpacket_values[1] < subpacket_values[2]),\r\n    \"7\" = as.numeric(subpacket_values[1] == subpacket_values[2])\r\n  )\r\n  \r\n  return(packet_value)\r\n}\r\ndecode_packet <- function(hex){\r\n  hex2bin(hex) |> read_packet()\r\n}\r\n\r\n\r\n\r\nDiscovered a few NAs and needed to go back and rewrite the bin2int function after it overflowed silently\r\n\r\n\r\ndecode_packet(input) |> evaluate_packet()\r\n\r\n\r\n[1] 1510977819698\r\n\r\n\r\nDay 17\r\nhttps://adventofcode.com/2021/day/17\r\n\r\n\r\nsuppressPackageStartupMessages({\r\n  library(tidyverse)\r\n  library(here)\r\n  library(glue)\r\n  \r\n  knitr::opts_chunk$set(echo = TRUE)\r\n})\r\n\r\noptions(scipen = 9999999)\r\noptions(dplyr.summarise.inform = FALSE)\r\n\r\n\r\n\r\n— Data —\r\n\r\n\r\n# tanho63/aoc.elf\r\naoc.elf::aoc_get(day = 17, year = 2021)\r\n\r\n\r\n\r\n\r\n\r\nreadLines(here::here(\"2021/day-17-input.txt\"))\r\n\r\n\r\n[1] \"target area: x=175..227, y=-134..-79\"\r\n\r\n— Part 1 —\r\n\r\n\r\nlaunch <- function(xv,yv){\r\n  x <- y <- max_y <- 0\r\n  success <- FALSE\r\n  \r\n  while(x < 227 & y > -134){\r\n    x <- x + xv\r\n    y <- y + yv\r\n    xv <- (sign(xv) * -1) + xv\r\n    yv <- yv - 1\r\n    \r\n    if(y > max_y) max_y <- y\r\n    \r\n    if(x >= 175 && x <= 227 && y >= -134 && y <= -79){\r\n      success <- TRUE \r\n      break\r\n    }\r\n  }\r\n  return(list(success = success, y = max_y))\r\n}\r\n\r\n\r\n\r\nsolve for some kind of system of equations? solve for inequalities? optim? guess and check lul\r\nHighest point of Y will involve X being the first point at which X reaches zero velocity within the range.\r\nSince x decreases by one and converges towards zero, x is equal to the sum of sequence that falls within the x range.\r\nThen Y is just “the highest y velocity that still falls within the success range” so search backwards til you find it.\r\n\r\n\r\nx <- 0\r\ny <- 1000\r\n\r\nrepeat {\r\n  r <- sum(seq_len(x))\r\n  if(r >= 175 && r <= 227) break\r\n  x <- x + 1\r\n}\r\n\r\nrepeat {\r\n  y <- y-1\r\n  res <- launch(x,y)\r\n  if(res$success) break\r\n  if(y < 0) break\r\n}\r\n\r\nres$y\r\n\r\n\r\n[1] 8911\r\n\r\n— Part 2 —\r\nI know:\r\nx min velocity is 19 from prev step\r\nx max velocity is 227 (xmax)\r\ny min velocity is -134 (ymin)\r\ny max velocity is 133 from prev step\r\n\r\nMake a search grid and launch em all!\r\n\r\n\r\ng <- crossing(x = 19:227, y = -134:133)\r\nmap2_lgl(g$x,g$y,~launch(.x,.y)$success) |> sum()\r\n\r\n\r\n[1] 4748\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:12:40-05:00"
    },
    {
      "path": "index.html",
      "title": "Tan's Advent of Code",
      "description": "A collection of my Advent of Code solutions.\n",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-12-17T13:12:41-05:00"
    }
  ],
  "collections": []
}
